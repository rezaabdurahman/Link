#!/bin/bash
# Terraform-Docker Compose Integration Script
# Syncs Terraform database outputs with Docker Compose environment

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
TERRAFORM_DIR="$PROJECT_ROOT/terraform"
DOCKER_COMPOSE_FILE="$PROJECT_ROOT/docker-compose.multi-instance.yml"
ENV_FILE="$PROJECT_ROOT/.env"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

warn() {
    echo -e "${YELLOW}‚ö†Ô∏è $1${NC}"
}

error() {
    echo -e "${RED}‚ùå $1${NC}"
}

usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Sync Terraform database outputs with Docker Compose environment.

OPTIONS:
    -e, --env ENV        Environment (development|staging|production)
    -f, --force          Force overwrite existing environment file
    -h, --help           Show this help message
    -d, --dry-run        Show what would be done without making changes
    -v, --verbose        Verbose output

EXAMPLES:
    $0 --env development
    $0 --env production --force
    $0 --dry-run

DESCRIPTION:
    This script extracts database credentials from Terraform outputs and
    creates/updates Docker Compose environment files for seamless local
    development and testing.

EOF
}

# Default values
ENVIRONMENT="development"
FORCE=false
DRY_RUN=false
VERBOSE=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -e|--env)
            ENVIRONMENT="$2"
            shift 2
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Validate environment
if [[ ! "$ENVIRONMENT" =~ ^(development|staging|production)$ ]]; then
    error "Invalid environment: $ENVIRONMENT"
    error "Must be one of: development, staging, production"
    exit 1
fi

log "Starting Terraform-Docker Compose sync for $ENVIRONMENT environment"

# Check if Terraform directory exists
if [[ ! -d "$TERRAFORM_DIR" ]]; then
    error "Terraform directory not found: $TERRAFORM_DIR"
    exit 1
fi

# Check if we're in a Terraform-managed directory
cd "$TERRAFORM_DIR"
if [[ ! -f "main.tf" ]]; then
    error "Not in a Terraform directory (no main.tf found)"
    exit 1
fi

# Check if Terraform state exists
if ! terraform show > /dev/null 2>&1; then
    warn "No Terraform state found. You may need to run: terraform init && terraform apply"
    warn "Attempting to get outputs anyway..."
fi

log "Extracting Terraform outputs..."

# Get Terraform outputs
if ! TERRAFORM_OUTPUTS=$(terraform output -json 2>/dev/null); then
    error "Failed to get Terraform outputs"
    error "Make sure you have run: terraform apply"
    exit 1
fi

# Check if we have the required outputs
if ! echo "$TERRAFORM_OUTPUTS" | jq -e '.service_database_connections' > /dev/null 2>&1; then
    error "Required Terraform output 'service_database_connections' not found"
    error "Make sure your Terraform configuration includes the service database outputs"
    exit 1
fi

# Create environment file path
ENV_DIR="$PROJECT_ROOT/.env"
mkdir -p "$ENV_DIR"

# Generate environment file content
generate_env_content() {
    cat << EOF
# Generated by sync-terraform-docker.sh
# Environment: $ENVIRONMENT
# Generated at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
# 
# DO NOT EDIT MANUALLY - This file is auto-generated from Terraform outputs
# To regenerate: ./scripts/sync-terraform-docker.sh --env $ENVIRONMENT

# ============================================
# DATABASE CONFIGURATION
# ============================================

EOF

    # Extract database configurations
    echo "$TERRAFORM_OUTPUTS" | jq -r '
        .service_database_connections.value | to_entries[] |
        "# " + (.key | ascii_upcase) + " SERVICE DATABASE" + "\n" +
        (.key | ascii_upcase) + "_SERVICE_DB_HOST=" + "pgbouncer" + "\n" +
        (.key | ascii_upcase) + "_SERVICE_DB_PORT=" + "5432" + "\n" +
        (.key | ascii_upcase) + "_SERVICE_DB_NAME=" + .value.database_name + "\n" +
        (.key | ascii_upcase) + "_SERVICE_DB_USER=" + .value.username + "\n" +
        (.key | ascii_upcase) + "_SERVICE_DB_PASSWORD=" + (.value.direct_connection_string | split("//")[1] | split(":")[1] | split("@")[0]) + "\n"
    '

    cat << EOF

# ============================================
# LEGACY DATABASE (for migration period)
# ============================================
DB_HOST=postgres
DB_PORT=5432
DB_USER=linkuser
DB_PASSWORD=linkpass
DB_NAME=linkdb

# ============================================
# PGBOUNCER CONFIGURATION
# ============================================
PGBOUNCER_ADMIN_PASSWORD=admin_secure_password
PGBOUNCER_STATS_PASSWORD=stats_secure_password

# ============================================
# ENVIRONMENT SETTINGS
# ============================================
ENVIRONMENT=$ENVIRONMENT
NODE_ENV=$ENVIRONMENT

EOF
}

# Generate the content
ENV_CONTENT=$(generate_env_content)

# Show what would be done in dry-run mode
if [[ "$DRY_RUN" = true ]]; then
    log "DRY RUN MODE - No changes will be made"
    echo ""
    echo "Would create/update file: $ENV_FILE"
    echo ""
    echo "Content preview:"
    echo "----------------------------------------"
    echo "$ENV_CONTENT" | head -n 30
    if [[ $(echo "$ENV_CONTENT" | wc -l) -gt 30 ]]; then
        echo "... (truncated, $(echo "$ENV_CONTENT" | wc -l) total lines)"
    fi
    echo "----------------------------------------"
    exit 0
fi

# Check if environment file exists and handle accordingly
if [[ -f "$ENV_FILE" ]] && [[ "$FORCE" = false ]]; then
    warn "Environment file already exists: $ENV_FILE"
    warn "Use --force to overwrite, or remove it manually"
    echo ""
    echo "Current file preview:"
    head -n 10 "$ENV_FILE"
    exit 1
fi

# Write the environment file
log "Writing environment file: $ENV_FILE"
echo "$ENV_CONTENT" > "$ENV_FILE"

success "Environment file created successfully"

# Create individual service environment files (for development)
if [[ "$ENVIRONMENT" = "development" ]]; then
    log "Creating individual service environment files..."
    
    # Extract service-specific environment files from Terraform
    if echo "$TERRAFORM_OUTPUTS" | jq -e '.environment_files_created' > /dev/null 2>&1; then
        success "Individual service .env files available in terraform/.env/"
    else
        warn "Individual service environment files not found in Terraform outputs"
    fi
fi

# Validate Docker Compose file integration
if [[ -f "$DOCKER_COMPOSE_FILE" ]]; then
    log "Validating Docker Compose integration..."
    
    # Check if Docker Compose file references our environment variables
    if grep -q "USER_SERVICE_DB_PASSWORD" "$DOCKER_COMPOSE_FILE"; then
        success "Docker Compose file is configured for Terraform integration"
    else
        warn "Docker Compose file may need updates for full Terraform integration"
    fi
else
    warn "Docker Compose file not found: $DOCKER_COMPOSE_FILE"
fi

# Print usage instructions
cat << EOF

üéâ Terraform-Docker Compose sync completed!

üìÅ Files created/updated:
   - $ENV_FILE

üöÄ Next steps:

1. Start your infrastructure:
   docker-compose -f docker-compose.multi-instance.yml up -d

2. Verify database connections:
   docker-compose ps
   docker-compose logs pgbouncer

3. Test service connectivity:
   ./scripts/test-database-connectivity.sh

üìö Useful commands:
   - View environment: cat $ENV_FILE
   - Re-sync: $0 --env $ENVIRONMENT --force
   - Dry run: $0 --env $ENVIRONMENT --dry-run

EOF

if [[ "$VERBOSE" = true ]]; then
    echo ""
    echo "üîç Verbose output:"
    echo "Environment: $ENVIRONMENT"
    echo "Terraform directory: $TERRAFORM_DIR" 
    echo "Environment file: $ENV_FILE"
    echo "Docker Compose file: $DOCKER_COMPOSE_FILE"
    echo ""
    echo "Terraform outputs summary:"
    echo "$TERRAFORM_OUTPUTS" | jq -r '.service_database_connections.value | keys | "Services: " + (join(", "))'
fi
