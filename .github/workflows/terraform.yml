name: Infrastructure (Terraform)

on:
  pull_request:
    paths: 
      - 'terraform/**'
      - '.github/workflows/terraform.yml'
  push:
    branches: [main, master]
    paths: 
      - 'terraform/**'
      - '.github/workflows/terraform.yml'

env:
  TF_VERSION: '1.5.7'  # Match local development version
  TF_WORKING_DIR: './terraform'

jobs:
  terraform-validate:
    name: Terraform Validate
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Terraform Format Check
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform fmt -check -recursive
      
      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -backend=false
      
      - name: Terraform Validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform validate

  terraform-plan:
    name: Terraform Plan
    if: github.event_name == 'pull_request'
    needs: [terraform-validate]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false  # Important: allows capturing raw output
      
      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -backend=false
      
      - name: Create terraform.tfvars for CI
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          cat > terraform.tfvars << EOF
          postgres_host = "localhost"
          postgres_password = "ci_test_password"
          postgres_user = "ci_user"
          environment = "ci"
          
          # CI-specific settings
          database_connection_limit = 20
          user_connection_limit = 10
          create_monitoring_user = false
          enable_pgbouncer = false
          enable_ssl = false
          backup_retention_days = 7
          
          # Kubernetes settings
          kubernetes_namespace = "default"
          kubeconfig_path = "~/.kube/config"
          kubernetes_context = "kind-kind"
          EOF
      
      - name: Terraform Plan (with output capture)
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # Run plan and capture output
          terraform plan -no-color -detailed-exitcode -out=tfplan.out > plan_output.txt 2>&1
          
          # Store exit code for later use
          echo "plan_exit_code=$?" >> $GITHUB_OUTPUT
          
          # Show plan output in logs
          cat plan_output.txt
        continue-on-error: true
      
      - name: Save plan file as artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ github.event.pull_request.number }}
          path: |
            ${{ env.TF_WORKING_DIR }}/tfplan.out
            ${{ env.TF_WORKING_DIR }}/plan_output.txt
          retention-days: 30
      
      - name: Comment Plan on PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Read the plan output
            const planOutput = fs.readFileSync('${{ env.TF_WORKING_DIR }}/plan_output.txt', 'utf8');
            const exitCode = '${{ steps.plan.outputs.plan_exit_code }}';
            
            // Determine plan status
            let status = '‚úÖ No changes';
            let emoji = '‚úÖ';
            if (exitCode === '1') {
              status = '‚ùå Plan failed';
              emoji = '‚ùå';
            } else if (exitCode === '2') {
              status = 'üìã Changes detected';
              emoji = 'üìã';
            }
            
            // Create comment body
            const body = `## ${emoji} Terraform Plan Results
            
            **Status**: ${status}
            **Working Directory**: \`${{ env.TF_WORKING_DIR }}\`
            **Terraform Version**: \`${{ env.TF_VERSION }}\`
            
            <details>
            <summary>üìã View Plan Output (Click to expand)</summary>
            
            \`\`\`hcl
            ${planOutput.length > 8000 ? planOutput.substring(0, 8000) + '\n\n... (truncated, see full output in artifacts)' : planOutput}
            \`\`\`
            
            </details>
            
            ### üìÅ Full Plan Output Available
            
            The complete Terraform plan is available as a workflow artifact:
            - **Artifact Name**: \`terraform-plan-${{ github.event.pull_request.number }}\`
            - **Files**: \`tfplan.out\` (binary), \`plan_output.txt\` (readable)
            - **Retention**: 30 days
            
            ### üîç How to Access Plan Output:
            
            1. **In this PR**: View the collapsed section above
            2. **GitHub UI**: Go to Actions ‚Üí This workflow run ‚Üí Artifacts
            3. **CLI**: \`gh run download ${{ github.run_id }} --name terraform-plan-${{ github.event.pull_request.number }}\`
            4. **Local**: Download and run \`terraform show tfplan.out\`
            
            ---
            *Generated by Terraform CI/CD Pipeline*`;
            
            // Post comment
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
      
      - name: Plan Status Check
        if: steps.plan.outputs.plan_exit_code == '1'
        run: |
          echo "‚ùå Terraform plan failed!"
          exit 1

  terraform-apply:
    name: Terraform Apply
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: [terraform-validate]
    runs-on: ubuntu-latest
    environment: production  # Requires manual approval for production changes
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      
      - name: Configure Terraform backend
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # Uncomment S3 backend for production
          # sed -i 's/# backend "s3"/backend "s3"/' main.tf
          echo "Using local backend for now"
      
      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init
        env:
          # Add these secrets to your GitHub repository
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      
      - name: Create production terraform.tfvars
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          cat > terraform.tfvars << EOF
          postgres_host = "${{ secrets.POSTGRES_HOST }}"
          postgres_password = "${{ secrets.POSTGRES_PASSWORD }}"
          postgres_user = "${{ secrets.POSTGRES_USER }}"
          environment = "production"
          
          # Production settings
          database_connection_limit = 100
          user_connection_limit = 50
          create_monitoring_user = true
          enable_pgbouncer = true
          enable_ssl = true
          backup_retention_days = 30
          
          # Kubernetes settings
          kubernetes_namespace = "link-production"
          kubeconfig_path = "~/.kube/config"
          kubernetes_context = "production-cluster"
          EOF
      
      - name: Terraform Plan (pre-apply)
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform plan -no-color -out=tfplan.out > apply_plan.txt 2>&1
          cat apply_plan.txt
      
      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform apply -auto-approve tfplan.out > apply_output.txt 2>&1
          cat apply_output.txt
      
      - name: Save apply results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: terraform-apply-results-${{ github.run_number }}
          path: |
            ${{ env.TF_WORKING_DIR }}/apply_plan.txt
            ${{ env.TF_WORKING_DIR }}/apply_output.txt
            ${{ env.TF_WORKING_DIR }}/terraform.tfstate
          retention-days: 90
      
      - name: Output infrastructure details
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "üéâ Infrastructure deployment complete!"
          echo ""
          echo "üìä Created Resources:"
          terraform output -json | jq -r 'to_entries[] | "- \(.key): \(.value.value // "[sensitive]")"'
      
      - name: Trigger post-deployment validation
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'post-deploy-validation.yml',
              ref: 'main',
              inputs: {
                environment: 'production',
                test_suite: 'all'
              }
            });

  terraform-drift-detection:
    name: Terraform Drift Detection
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Check for infrastructure drift
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init
          terraform plan -detailed-exitcode > drift_check.txt 2>&1 || {
            if [ $? -eq 2 ]; then
              echo "üö® Infrastructure drift detected!"
              cat drift_check.txt
              exit 1
            fi
          }
          echo "‚úÖ No infrastructure drift detected"

# Add schedule for weekly drift detection
on:
  schedule:
    - cron: '0 9 * * 1'  # Every Monday at 9 AM
  workflow_dispatch:  # Manual trigger
