name: Qdrant Infrastructure Deployment

on:
  pull_request:
    paths:
      - 'terraform/modules/qdrant-cluster/**'
      - 'terraform/modules/search-service-config/**'
      - 'terraform/environments/*/qdrant.tfvars'
      - 'backend/search-svc/**'
      - '.github/workflows/qdrant-deployment.yml'
  push:
    branches: [main]
    paths:
      - 'terraform/modules/qdrant-cluster/**'
      - 'terraform/modules/search-service-config/**'
      - 'terraform/environments/*/qdrant.tfvars'
      - 'backend/search-svc/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging  
          - production
      destroy:
        description: 'Destroy infrastructure'
        required: false
        default: false
        type: boolean

env:
  TF_VERSION: '1.5.7'
  KUBECTL_VERSION: '1.28.0'

jobs:
  # Validate Qdrant Configuration
  validate-qdrant:
    name: Validate Qdrant Configuration
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Validate Qdrant module
        working-directory: terraform/modules/qdrant-cluster
        run: |
          terraform init -backend=false
          terraform validate
          terraform fmt -check
      
      - name: Validate Search Service Config module
        working-directory: terraform/modules/search-service-config
        run: |
          terraform init -backend=false
          terraform validate
          terraform fmt -check
      
      - name: Validate environment configurations
        run: |
          for env in development production; do
            echo "Validating $env environment..."
            cd terraform/environments/$env
            terraform init -backend=false
            terraform validate
            cd ../../..
          done

  # Test Search Service with Qdrant
  test-search-service:
    name: Test Search Service
    runs-on: ubuntu-latest
    needs: [validate-qdrant]
    
    services:
      qdrant:
        image: qdrant/qdrant:v1.11.0
        ports:
          - 6333:6333
          - 6334:6334
        env:
          QDRANT__SERVICE__HTTP_PORT: 6333
          QDRANT__SERVICE__GRPC_PORT: 6334
        options: >-
          --health-cmd "curl -f http://localhost:6333/health"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
      
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-search-svc-${{ hashFiles('backend/search-svc/go.sum') }}
      
      - name: Test search service with Qdrant
        working-directory: backend/search-svc
        env:
          SEARCH_REPOSITORY_TYPE: qdrant
          QDRANT_HOST: localhost
          QDRANT_PORT: 6334
          QDRANT_USE_TLS: false
          QDRANT_COLLECTION: test_collection
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY_TEST }}
        run: |
          go mod tidy
          go test -v -race -coverprofile=coverage.out ./...
          
          # Test Qdrant connectivity
          curl -f http://localhost:6333/health
          
          # Test collection creation (if implemented)
          if [ -f "./scripts/test-qdrant-setup.sh" ]; then
            chmod +x ./scripts/test-qdrant-setup.sh
            ./scripts/test-qdrant-setup.sh
          fi
      
      - name: Upload test coverage
        uses: actions/upload-artifact@v4
        with:
          name: search-svc-qdrant-coverage
          path: backend/search-svc/coverage.out

  # Plan Qdrant Deployment
  plan-qdrant:
    name: Plan Qdrant Deployment
    if: github.event_name == 'pull_request'
    needs: [validate-qdrant, test-search-service]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [development, production]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}
      
      - name: Configure AWS credentials (for production)
        if: matrix.environment == 'production'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2
      
      - name: Terraform Init
        working-directory: terraform/environments/${{ matrix.environment }}
        run: |
          terraform init
        env:
          TF_BACKEND_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
          TF_BACKEND_KEY: ${{ matrix.environment }}/qdrant/terraform.tfstate
      
      - name: Create terraform variables
        working-directory: terraform/environments/${{ matrix.environment }}
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          SERVICE_AUTH_TOKEN: ${{ secrets.SERVICE_AUTH_TOKEN }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          # Create terraform.tfvars for secrets
          cat > terraform.auto.tfvars << EOF
          openai_api_key = "$OPENAI_API_KEY"
          service_auth_token = "$SERVICE_AUTH_TOKEN"
          db_password = "$DB_PASSWORD"
          EOF
          
          # Production-specific secrets
          if [ "${{ matrix.environment }}" = "production" ]; then
            cat >> terraform.auto.tfvars << EOF
            kms_key_id = "alias/link-production-key"
            EOF
          fi
      
      - name: Terraform Plan
        id: plan
        working-directory: terraform/environments/${{ matrix.environment }}
        run: |
          terraform plan \
            -var-file="qdrant.tfvars" \
            -out=qdrant-plan-${{ matrix.environment }}.out \
            -no-color > plan-output-${{ matrix.environment }}.txt 2>&1
          
          echo "plan_exit_code=$?" >> $GITHUB_OUTPUT
          cat plan-output-${{ matrix.environment }}.txt
        continue-on-error: true
      
      - name: Save plan artifacts
        uses: actions/upload-artifact@v4
        with:
          name: qdrant-plan-${{ matrix.environment }}-${{ github.event.pull_request.number }}
          path: |
            terraform/environments/${{ matrix.environment }}/qdrant-plan-${{ matrix.environment }}.out
            terraform/environments/${{ matrix.environment }}/plan-output-${{ matrix.environment }}.txt
          retention-days: 30
      
      - name: Comment Plan on PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const planOutput = fs.readFileSync('terraform/environments/${{ matrix.environment }}/plan-output-${{ matrix.environment }}.txt', 'utf8');
            const exitCode = '${{ steps.plan.outputs.plan_exit_code }}';
            
            let status = '‚úÖ No changes';
            let emoji = '‚úÖ';
            if (exitCode === '1') {
              status = '‚ùå Plan failed';
              emoji = '‚ùå';
            } else if (exitCode === '2') {
              status = 'üìã Changes detected';
              emoji = 'üìã';
            }
            
            const body = `## ${emoji} Qdrant Deployment Plan - ${{ matrix.environment }}
            
            **Status**: ${status}
            **Environment**: \`${{ matrix.environment }}\`
            **Terraform Version**: \`${{ env.TF_VERSION }}\`
            
            <details>
            <summary>üìã View Qdrant Plan Output (Click to expand)</summary>
            
            \`\`\`hcl
            ${planOutput.length > 6000 ? planOutput.substring(0, 6000) + '\n\n... (truncated)' : planOutput}
            \`\`\`
            
            </details>
            
            ### üéØ Qdrant Resources:
            - **Cluster Size**: 3 nodes (production) / 1 node (development)
            - **Storage**: ${matrix.environment === 'production' ? 'AWS EBS encrypted' : 'Local storage'}
            - **Backups**: ${matrix.environment === 'production' ? 'S3 automated' : 'Disabled'}
            - **Load Balancer**: ${matrix.environment === 'production' ? 'AWS NLB' : 'ClusterIP'}
            
            ---
            *Qdrant CI/CD Pipeline*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # Deploy Qdrant to Development
  deploy-development:
    name: Deploy Qdrant (Development)
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: [validate-qdrant, test-search-service]
    runs-on: ubuntu-latest
    environment: development
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}
      
      - name: Deploy to development
        working-directory: terraform/environments/development
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY_DEV }}
          SERVICE_AUTH_TOKEN: ${{ secrets.SERVICE_AUTH_TOKEN_DEV }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD_DEV }}
        run: |
          terraform init
          
          # Create variables
          cat > terraform.auto.tfvars << EOF
          openai_api_key = "$OPENAI_API_KEY"
          service_auth_token = "$SERVICE_AUTH_TOKEN"
          db_password = "$DB_PASSWORD"
          EOF
          
          # Apply
          terraform plan -var-file="qdrant.tfvars" -out=dev-apply.out
          terraform apply -auto-approve dev-apply.out
          
          # Output results
          terraform output -json > qdrant-dev-outputs.json
      
      - name: Save deployment results
        uses: actions/upload-artifact@v4
        with:
          name: qdrant-dev-deployment-${{ github.run_number }}
          path: |
            terraform/environments/development/qdrant-dev-outputs.json
            terraform/environments/development/.terraform/terraform.tfstate
          retention-days: 30

  # Deploy Qdrant to Production  
  deploy-production:
    name: Deploy Qdrant (Production)
    if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    needs: [validate-qdrant, test-search-service]
    runs-on: ubuntu-latest
    environment: production  # Requires manual approval
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2
      
      - name: Deploy to production
        working-directory: terraform/environments/production
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY_PROD }}
          SERVICE_AUTH_TOKEN: ${{ secrets.SERVICE_AUTH_TOKEN_PROD }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD_PROD }}
        run: |
          terraform init
          
          # Create variables
          cat > terraform.auto.tfvars << EOF
          openai_api_key = "$OPENAI_API_KEY"
          service_auth_token = "$SERVICE_AUTH_TOKEN"
          db_password = "$DB_PASSWORD"
          kms_key_id = "alias/link-production-key"
          EOF
          
          # Handle destroy if requested
          if [ "${{ github.event.inputs.destroy }}" = "true" ]; then
            echo "üö® Destroying Qdrant infrastructure..."
            terraform plan -destroy -var-file="qdrant.tfvars" -out=destroy.out
            terraform apply -auto-approve destroy.out
          else
            # Normal deployment
            terraform plan -var-file="qdrant.tfvars" -out=prod-apply.out
            terraform apply -auto-approve prod-apply.out
            
            # Output results
            terraform output -json > qdrant-prod-outputs.json
            
            echo "üéâ Qdrant production deployment complete!"
            echo "Cluster endpoint: $(terraform output -raw qdrant_cluster_info | jq -r '.endpoint')"
          fi
      
      - name: Save deployment results
        if: github.event.inputs.destroy != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: qdrant-prod-deployment-${{ github.run_number }}
          path: |
            terraform/environments/production/qdrant-prod-outputs.json
            terraform/environments/production/.terraform/terraform.tfstate
          retention-days: 90
      
      - name: Trigger search service deployment
        if: github.event.inputs.destroy != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              ref: 'main',
              inputs: {
                service: 'search-svc',
                environment: 'production'
              }
            });

  # Validate Deployment
  validate-deployment:
    name: Validate Qdrant Deployment
    if: (github.ref == 'refs/heads/main' && github.event_name == 'push') || github.event_name == 'workflow_dispatch'
    needs: [deploy-development]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}
      
      - name: Validate Qdrant cluster health
        env:
          ENVIRONMENT: ${{ github.event.inputs.environment || 'development' }}
        run: |
          echo "üîç Validating Qdrant deployment in $ENVIRONMENT..."
          
          # Port forward to Qdrant
          kubectl port-forward svc/qdrant-cluster 6333:6333 -n link-${ENVIRONMENT} &
          PF_PID=$!
          sleep 10
          
          # Test health endpoints
          echo "Testing Qdrant health..."
          curl -f http://localhost:6333/health
          
          echo "Testing cluster status..."
          curl -s http://localhost:6333/cluster | jq .
          
          echo "Testing collections endpoint..."
          curl -s http://localhost:6333/collections | jq .
          
          # Cleanup
          kill $PF_PID
          
          echo "‚úÖ Qdrant validation complete!"

# Add schedule for drift detection
on:
  schedule:
    - cron: '0 6 * * 1'  # Every Monday at 6 AM
  workflow_dispatch: