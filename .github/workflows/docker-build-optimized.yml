name: Optimized Docker Build Pipeline

on:
  workflow_call:
    inputs:
      services:
        description: 'Services to build (JSON array)'
        required: false
        type: string
        default: '["api-gateway", "user-svc", "chat-svc", "discovery-svc", "ai-svc", "search-svc", "frontend"]'
      environment:
        description: 'Target environment'
        required: false
        type: string
        default: 'development'
      push_images:
        description: 'Push built images to registry'
        required: false
        type: boolean
        default: true
      cache_mode:
        description: 'Cache mode: registry, local, or gha'
        required: false
        type: string
        default: 'registry'
        
  workflow_dispatch:
    inputs:
      services:
        description: 'Services to build'
        required: true
        type: choice
        options: ['all', 'backend-only', 'frontend-only', 'api-gateway', 'user-svc', 'chat-svc', 'discovery-svc', 'ai-svc', 'search-svc']
        default: 'all'
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options: ['development', 'staging', 'production']
        default: 'development'
      push_images:
        description: 'Push built images to registry'
        required: false
        type: boolean
        default: true
      force_rebuild:
        description: 'Force rebuild without cache'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}
  DOCKER_BUILDKIT: 1
  BUILDX_NO_DEFAULT_ATTESTATIONS: 1

concurrency:
  group: docker-build-${{ github.ref }}-${{ inputs.environment || 'dev' }}
  cancel-in-progress: true

jobs:
  # ================================================================
  # STAGE 0: BUILD STRATEGY & OPTIMIZATION
  # ================================================================
  
  build-strategy:
    name: üéØ Build Strategy & Cache Warming
    runs-on: ubuntu-latest
    outputs:
      services-matrix: ${{ steps.strategy.outputs.services }}
      cache-strategy: ${{ steps.strategy.outputs.cache_strategy }}
      parallel-builds: ${{ steps.strategy.outputs.parallel_builds }}
      build-order: ${{ steps.strategy.outputs.build_order }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Determine build strategy
      id: strategy
      run: |
        echo "üéØ Docker Build Strategy Analysis"
        echo "================================="
        echo ""
        
        # Determine services to build
        if [[ "${{ github.event.inputs.services }}" == "all" ]] || [[ "${{ inputs.services }}" == "" ]]; then
          services='["api-gateway", "user-svc", "chat-svc", "discovery-svc", "ai-svc", "search-svc", "frontend"]'
        elif [[ "${{ github.event.inputs.services }}" == "backend-only" ]]; then
          services='["api-gateway", "user-svc", "chat-svc", "discovery-svc", "ai-svc", "search-svc"]'
        elif [[ "${{ github.event.inputs.services }}" == "frontend-only" ]]; then
          services='["frontend"]'
        elif [[ "${{ github.event.inputs.services }}" != "" ]]; then
          services='["${{ github.event.inputs.services }}"]'
        else
          services='${{ inputs.services }}'
        fi
        
        # Determine cache strategy
        cache_strategy="registry"
        if [[ "${{ github.event.inputs.force_rebuild }}" == "true" ]]; then
          cache_strategy="none"
        elif [[ "${{ inputs.cache_mode }}" != "" ]]; then
          cache_strategy="${{ inputs.cache_mode }}"
        fi
        
        # Determine build parallelization
        service_count=$(echo "$services" | jq '. | length')
        if [[ $service_count -le 3 ]]; then
          parallel_builds="high"    # 3 concurrent builds max
        elif [[ $service_count -le 6 ]]; then
          parallel_builds="medium"  # 2 concurrent builds max
        else
          parallel_builds="low"     # 1 concurrent build max (sequential)
        fi
        
        # Build order optimization (dependencies first)
        # API Gateway depends on nothing (base Go image)
        # Services depend on shared-libs
        # Frontend depends on nothing (base Node image)
        build_order='["api-gateway", "user-svc", "chat-svc", "discovery-svc", "ai-svc", "search-svc", "frontend"]'
        
        echo "services=$services" >> $GITHUB_OUTPUT
        echo "cache_strategy=$cache_strategy" >> $GITHUB_OUTPUT
        echo "parallel_builds=$parallel_builds" >> $GITHUB_OUTPUT
        echo "build_order=$build_order" >> $GITHUB_OUTPUT
        
        echo "üìä Build Strategy:"
        echo "  Services: $services"
        echo "  Cache strategy: $cache_strategy"
        echo "  Parallelization: $parallel_builds"
        echo "  Service count: $service_count"
        
    - name: Warm up base image caches
      run: |
        echo "üî• Warming up base image caches..."
        
        # Pre-pull common base images to improve cache hits
        base_images=(
          "node:18-alpine"
          "golang:1.23-alpine"
          "alpine:3.18"
          "nginx:1.25-alpine"
        )
        
        for image in "${base_images[@]}"; do
          echo "Pre-pulling: $image"
          docker pull "$image" &
        done
        
        # Wait for all pulls to complete
        wait
        
        echo "‚úÖ Base image cache warm-up completed"

  # ================================================================
  # STAGE 1: PARALLEL DOCKER BUILDS
  # ================================================================
  
  build-images:
    name: üê≥ Build ${{ matrix.service }}
    needs: build-strategy
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: ${{ needs.build-strategy.outputs.parallel-builds == 'high' && 3 || needs.build-strategy.outputs.parallel-builds == 'medium' && 2 || 1 }}
      matrix:
        service: ${{ fromJson(needs.build-strategy.outputs.services-matrix) }}
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Log in to Container Registry
      if: inputs.push_images == true || github.event.inputs.push_images == 'true'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Determine build context and dockerfile
      id: build-context
      run: |
        service="${{ matrix.service }}"
        
        case "$service" in
          "frontend")
            context="./frontend"
            dockerfile="./frontend/Dockerfile"
            ;;
          "api-gateway"|"user-svc"|"chat-svc"|"discovery-svc"|"ai-svc"|"search-svc")
            context="./backend/$service"
            dockerfile="./backend/$service/Dockerfile"
            ;;
          *)
            echo "‚ùå Unknown service: $service"
            exit 1
            ;;
        esac
        
        echo "context=$context" >> $GITHUB_OUTPUT
        echo "dockerfile=$dockerfile" >> $GITHUB_OUTPUT
        echo "üìç Build context: $context"
        echo "üìÑ Dockerfile: $dockerfile"

    - name: Generate build arguments
      id: build-args
      run: |
        service="${{ matrix.service }}"
        environment="${{ inputs.environment || github.event.inputs.environment || 'development' }}"
        
        # Common build args
        BUILD_ARGS="SERVICE_NAME=$service"
        BUILD_ARGS="$BUILD_ARGS
        ENVIRONMENT=$environment"
        BUILD_ARGS="$BUILD_ARGS
        BUILD_VERSION=${{ github.sha }}"
        BUILD_ARGS="$BUILD_ARGS
        BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
        
        # Service-specific build args
        case "$service" in
          "frontend")
            BUILD_ARGS="$BUILD_ARGS
            VITE_API_BASE_URL=/api/v1
            VITE_WS_BASE_URL=/ws"
            ;;
          "api-gateway"|"user-svc"|"chat-svc"|"discovery-svc"|"ai-svc"|"search-svc")
            BUILD_ARGS="$BUILD_ARGS
            CGO_ENABLED=0
            GOOS=linux"
            ;;
        esac
        
        # Environment-specific args
        case "$environment" in
          "production")
            BUILD_ARGS="$BUILD_ARGS
            NODE_ENV=production
            VITE_APP_MODE=production
            APP_ENV=production"
            ;;
          "staging")
            BUILD_ARGS="$BUILD_ARGS
            NODE_ENV=production
            VITE_APP_MODE=staging
            APP_ENV=staging"
            ;;
          "test")
            BUILD_ARGS="$BUILD_ARGS
            NODE_ENV=test
            VITE_APP_MODE=test
            APP_ENV=test"
            ;;
          *)
            BUILD_ARGS="$BUILD_ARGS
            NODE_ENV=development
            VITE_APP_MODE=development
            APP_ENV=development"
            ;;
        esac
        
        echo "args<<EOF" >> $GITHUB_OUTPUT
        echo "$BUILD_ARGS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Build Docker image with caching
      id: build
      uses: ./.github/actions/docker-build-cache
      with:
        context: ${{ steps.build-context.outputs.context }}
        dockerfile: ${{ steps.build-context.outputs.dockerfile }}
        image-name: ${{ env.IMAGE_PREFIX }}/${{ matrix.service }}
        image-tag: ${{ github.sha }}
        registry: ${{ env.REGISTRY }}
        push: ${{ inputs.push_images || github.event.inputs.push_images || true }}
        build-args: ${{ steps.build-args.outputs.args }}
        platforms: linux/amd64,linux/arm64
        cache-mode: ${{ needs.build-strategy.outputs.cache-strategy == 'none' && 'registry' || needs.build-strategy.outputs.cache-strategy }}

    - name: Test built image
      run: |
        echo "üß™ Testing built image: ${{ matrix.service }}"
        
        service="${{ matrix.service }}"
        image="${{ steps.build.outputs.image-url }}"
        
        # Basic image inspection
        docker buildx imagetools inspect "$image"
        
        # Service-specific smoke tests
        case "$service" in
          "frontend")
            echo "Testing frontend image..."
            docker run --rm "$image" node --version
            docker run --rm "$image" nginx -t
            ;;
          *)
            echo "Testing Go service image..."
            # Test that the binary exists and is executable
            docker run --rm "$image" /app/"$service" --version 2>/dev/null || \
            docker run --rm "$image" /app/"$service" -version 2>/dev/null || \
            docker run --rm "$image" ls -la /app/
            ;;
        esac
        
        echo "‚úÖ Image test completed for $service"

    - name: Scan for vulnerabilities
      if: inputs.environment == 'production' || github.event.inputs.environment == 'production'
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.build.outputs.image-url }}
        format: 'sarif'
        output: 'trivy-results-${{ matrix.service }}.sarif'
        severity: 'HIGH,CRITICAL'
        exit-code: '0'  # Don't fail build on vulnerabilities, just report

    - name: Upload vulnerability scan results
      if: inputs.environment == 'production' || github.event.inputs.environment == 'production'
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results-${{ matrix.service }}.sarif'
        category: 'docker-${{ matrix.service }}'

  # ================================================================
  # STAGE 2: BUILD VERIFICATION & SUMMARY
  # ================================================================
  
  build-summary:
    name: üìã Build Summary & Verification
    needs: [build-strategy, build-images]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Collect build results
      id: results
      run: |
        echo "üìä DOCKER BUILD SUMMARY"
        echo "======================"
        echo ""
        
        # Parse results from matrix jobs
        services='${{ needs.build-strategy.outputs.services-matrix }}'
        total_services=$(echo "$services" | jq '. | length')
        
        # Note: We can't directly access matrix job results in needs context
        # This would require a more complex setup with job outputs
        # For now, we'll provide a summary based on job completion
        
        echo "üê≥ Build Configuration:"
        echo "  Services built: $total_services"
        echo "  Cache strategy: ${{ needs.build-strategy.outputs.cache-strategy }}"
        echo "  Parallelization: ${{ needs.build-strategy.outputs.parallel-builds }}"
        echo "  Push to registry: ${{ inputs.push_images || github.event.inputs.push_images || true }}"
        echo ""
        
        # Determine overall status
        if [[ "${{ needs.build-images.result }}" == "success" ]]; then
          overall_status="success"
          status_message="‚úÖ All Docker images built successfully"
        elif [[ "${{ needs.build-images.result }}" == "failure" ]]; then
          overall_status="failure"
          status_message="‚ùå Some Docker image builds failed"
        else
          overall_status="partial"
          status_message="‚ö†Ô∏è Docker image builds completed with mixed results"
        fi
        
        echo "overall_status=$overall_status" >> $GITHUB_OUTPUT
        echo "status_message=$status_message" >> $GITHUB_OUTPUT
        echo "total_services=$total_services" >> $GITHUB_OUTPUT
        
        echo "$status_message"

    - name: Generate build report
      run: |
        echo "# üê≥ Docker Build Pipeline Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Build Status:** ${{ steps.results.outputs.status_message }}" >> $GITHUB_STEP_SUMMARY
        echo "**Services Built:** ${{ steps.results.outputs.total_services }}" >> $GITHUB_STEP_SUMMARY
        echo "**Cache Strategy:** ${{ needs.build-strategy.outputs.cache-strategy }}" >> $GITHUB_STEP_SUMMARY
        echo "**Parallelization:** ${{ needs.build-strategy.outputs.parallel-builds }}" >> $GITHUB_STEP_SUMMARY
        echo "**Registry:** ${{ env.REGISTRY }}" >> $GITHUB_STEP_SUMMARY
        echo "**Images Pushed:** ${{ inputs.push_images || github.event.inputs.push_images || true }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "## üì¶ Built Services" >> $GITHUB_STEP_SUMMARY
        echo "| Service | Status | Image Tag |" >> $GITHUB_STEP_SUMMARY
        echo "|---------|--------|-----------|" >> $GITHUB_STEP_SUMMARY
        
        # List services from matrix
        services='${{ needs.build-strategy.outputs.services-matrix }}'
        echo "$services" | jq -r '.[]' | while read service; do
          echo "| $service | ${{ needs.build-images.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }} | \`${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/$service:${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
        done
        
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [[ "${{ steps.results.outputs.overall_status }}" == "success" ]]; then
          echo "## ‚úÖ Build Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All Docker images have been built and are ready for deployment." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- Images are available in the container registry" >> $GITHUB_STEP_SUMMARY
          echo "- Run deployment pipeline to deploy to target environment" >> $GITHUB_STEP_SUMMARY
          echo "- Monitor build cache efficiency for future optimizations" >> $GITHUB_STEP_SUMMARY
        else
          echo "## ‚ùå Build Issues" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Some Docker image builds encountered issues. Please check individual build logs." >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "üí° **Performance Optimization**: This pipeline uses advanced caching strategies to minimize build times:" >> $GITHUB_STEP_SUMMARY
        echo "- **Multi-layer caching** with BuildKit" >> $GITHUB_STEP_SUMMARY
        echo "- **Registry cache sharing** across builds" >> $GITHUB_STEP_SUMMARY
        echo "- **Parallel builds** with dependency optimization" >> $GITHUB_STEP_SUMMARY
        echo "- **Base image pre-warming** for faster starts" >> $GITHUB_STEP_SUMMARY

    - name: Cleanup build cache
      if: always() && needs.build-strategy.outputs.cache-strategy == 'local'
      run: |
        echo "üßπ Cleaning up local build cache..."
        docker buildx prune -f --filter until=24h
        echo "‚úÖ Cache cleanup completed"

    - name: Fail if builds failed
      if: steps.results.outputs.overall_status == 'failure'
      run: |
        echo "‚ùå Docker build pipeline failed"
        exit 1