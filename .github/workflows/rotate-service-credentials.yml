name: Rotate Service Credentials

on:
  # Automatic rotation every 30 days
  schedule:
    - cron: '0 2 1 * *'  # 2 AM on the 1st of every month
  
  # Manual trigger for immediate rotation
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment'
        required: true
        type: choice
        options:
        - staging
        - production
      service:
        description: 'Service to rotate (leave empty for all)'
        required: false
        type: choice
        options:
        - ''
        - user-svc
        - chat-svc
        - ai-svc
        - discovery-svc
        - search-svc
        - application-secrets
      force_rotation:
        description: 'Force rotation even if credentials are recent'
        required: false
        type: boolean
        default: false

jobs:
  rotate-credentials:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ github.event.inputs.environment && fromJson(format('["{0}"]', github.event.inputs.environment)) || fromJson('["staging", "production"]') }}
        service: ${{ github.event.inputs.service && fromJson(format('["{0}"]', github.event.inputs.service)) || fromJson('["user-svc", "chat-svc", "ai-svc", "discovery-svc", "search-svc", "application-secrets"]') }}
      fail-fast: false  # Don't stop other rotations if one fails
      max-parallel: 2   # Limit concurrent rotations

    environment: ${{ matrix.environment }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION || 'us-west-2' }}

    - name: Configure kubectl
      uses: azure/k8s-set-context@v3
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.KUBECONFIG }}

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y postgresql-client apache2-utils jq

    - name: Set environment variables
      run: |
        case "${{ matrix.environment }}" in
          "production")
            echo "DB_HOST=${{ secrets.PROD_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.PROD_DB_PORT || '5432' }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.PROD_DB_NAME }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.PROD_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "SECRETS_BACKEND=${{ vars.PROD_SECRETS_BACKEND || 'aws' }}" >> $GITHUB_ENV
            echo "MIN_AGE_DAYS=7" >> $GITHUB_ENV  # Minimum age before rotation
            ;;
          "staging")
            echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.STAGING_DB_PORT || '5432' }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.STAGING_DB_NAME }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.STAGING_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "SECRETS_BACKEND=${{ vars.STAGING_SECRETS_BACKEND || 'kubernetes' }}" >> $GITHUB_ENV
            echo "MIN_AGE_DAYS=3" >> $GITHUB_ENV   # More frequent rotation in staging
            ;;
        esac
        
        echo "ENVIRONMENT=${{ matrix.environment }}" >> $GITHUB_ENV
        echo "SERVICE=${{ matrix.service }}" >> $GITHUB_ENV
        echo "FORCE_ROTATION=${{ github.event.inputs.force_rotation || 'false' }}" >> $GITHUB_ENV

    - name: Handle application secrets rotation
      if: matrix.service == 'application-secrets'
      run: |
        echo "üîê Rotating application secrets (JWT, encryption keys)..."
        
        # Set force flag if requested
        FORCE_FLAG=""
        if [[ "${{ github.event.inputs.force_rotation }}" == "true" ]]; then
          FORCE_FLAG="--force"
        fi
        
        # Run application secrets rotation
        ./scripts/rotate-application-secrets.sh "${{ matrix.environment }}" $FORCE_FLAG
        
        echo "‚úÖ Application secrets rotation completed"
        exit 0  # Skip the rest of the workflow for application secrets

    - name: Check if rotation is needed
      if: matrix.service != 'application-secrets'
      id: check_rotation
      run: |
        # Check when credentials were last updated
        last_updated=$(PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c \
          "SELECT updated_at FROM service_accounts WHERE name = '$SERVICE';" | xargs)
        
        if [ -z "$last_updated" ]; then
          echo "‚ùå Service account not found: $SERVICE"
          echo "needs_rotation=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Calculate age in days
        last_updated_epoch=$(date -d "$last_updated" +%s)
        current_epoch=$(date +%s)
        age_seconds=$((current_epoch - last_updated_epoch))
        age_days=$((age_seconds / 86400))
        
        echo "Service $SERVICE credentials were last updated $age_days days ago"
        
        # Check if rotation is needed
        if [ "$FORCE_ROTATION" = "true" ]; then
          echo "‚úÖ Force rotation requested"
          echo "needs_rotation=true" >> $GITHUB_OUTPUT
        elif [ $age_days -ge $MIN_AGE_DAYS ]; then
          echo "‚úÖ Credentials are $age_days days old (>= $MIN_AGE_DAYS days), rotation needed"
          echo "needs_rotation=true" >> $GITHUB_OUTPUT
        else
          echo "‚è≠Ô∏è Credentials are only $age_days days old (< $MIN_AGE_DAYS days), skipping rotation"
          echo "needs_rotation=false" >> $GITHUB_OUTPUT
        fi

    - name: Create pre-rotation backup
      if: steps.check_rotation.outputs.needs_rotation == 'true'
      run: |
        # Backup current service account configuration
        PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c \
          "COPY (SELECT * FROM service_accounts WHERE name = '$SERVICE') TO STDOUT WITH CSV HEADER;" > "${SERVICE}_backup_$(date +%Y%m%d_%H%M%S).csv"
        
        # Also backup from secrets store
        case "$SECRETS_BACKEND" in
          "aws")
            aws secretsmanager get-secret-value --secret-id "link-app/${ENVIRONMENT}/${SERVICE}/service-account" \
              --query SecretString --output text > "${SERVICE}_secrets_backup_$(date +%Y%m%d_%H%M%S).json" || true
            ;;
          "kubernetes")
            kubectl get secret "${SERVICE}-service-account" -o yaml > "${SERVICE}_k8s_backup_$(date +%Y%m%d_%H%M%S).yaml" || true
            ;;
        esac

    - name: Perform credential rotation
      if: steps.check_rotation.outputs.needs_rotation == 'true'
      run: |
        chmod +x scripts/setup-service-accounts.sh
        
        echo "üîÑ Rotating credentials for $SERVICE in $ENVIRONMENT..."
        if ./scripts/setup-service-accounts.sh rotate "$SERVICE"; then
          echo "‚úÖ Credential rotation successful"
          echo "ROTATION_SUCCESS=true" >> $GITHUB_ENV
        else
          echo "‚ùå Credential rotation failed"
          echo "ROTATION_SUCCESS=false" >> $GITHUB_ENV
          exit 1
        fi

    - name: Verify new credentials work
      if: steps.check_rotation.outputs.needs_rotation == 'true' && env.ROTATION_SUCCESS == 'true'
      run: |
        echo "üîç Verifying new credentials..."
        
        # Get new credentials
        case "$SECRETS_BACKEND" in
          "aws")
            CLIENT_ID=$(aws secretsmanager get-secret-value --secret-id "link-app/${ENVIRONMENT}/${SERVICE}/service-account" \
              --query SecretString --output text | jq -r '.SERVICE_CLIENT_ID')
            CLIENT_SECRET=$(aws secretsmanager get-secret-value --secret-id "link-app/${ENVIRONMENT}/${SERVICE}/service-account" \
              --query SecretString --output text | jq -r '.SERVICE_CLIENT_SECRET')
            AUTH_URL=$(aws secretsmanager get-secret-value --secret-id "link-app/${ENVIRONMENT}/${SERVICE}/service-account" \
              --query SecretString --output text | jq -r '.AUTH_SERVICE_URL')
            ;;
          "kubernetes")
            CLIENT_ID=$(kubectl get secret "${SERVICE}-service-account" -o jsonpath="{.data.SERVICE_CLIENT_ID}" | base64 -d)
            CLIENT_SECRET=$(kubectl get secret "${SERVICE}-service-account" -o jsonpath="{.data.SERVICE_CLIENT_SECRET}" | base64 -d)
            AUTH_URL=$(kubectl get secret "${SERVICE}-service-account" -o jsonpath="{.data.AUTH_SERVICE_URL}" | base64 -d)
            ;;
        esac
        
        # Test token request
        if curl -s -f -X POST "$AUTH_URL/api/v1/auth/service-token" \
          -H "Content-Type: application/x-www-form-urlencoded" \
          -d "grant_type=client_credentials&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET" \
          > token_response.json; then
          
          echo "‚úÖ New credentials verified successfully"
          token=$(jq -r '.access_token' token_response.json)
          echo "Token obtained: ${token:0:20}..."
          
        else
          echo "‚ùå New credentials verification failed"
          echo "VERIFICATION_FAILED=true" >> $GITHUB_ENV
          exit 1
        fi

    - name: Rolling restart of service
      if: steps.check_rotation.outputs.needs_rotation == 'true' && env.ROTATION_SUCCESS == 'true' && env.VERIFICATION_FAILED != 'true'
      run: |
        echo "üîÑ Performing rolling restart of $SERVICE deployment..."
        
        if kubectl get deployment "$SERVICE" &> /dev/null; then
          # Add annotation to trigger rolling update
          kubectl patch deployment "$SERVICE" -p \
            '{"spec":{"template":{"metadata":{"annotations":{"credential-rotation/timestamp":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}}}}}'
          
          # Wait for rollout to complete
          echo "Waiting for $SERVICE rollout to complete..."
          kubectl rollout status deployment/"$SERVICE" --timeout=600s
          
          echo "‚úÖ Rolling restart completed for $SERVICE"
        else
          echo "‚ö†Ô∏è Deployment $SERVICE not found, skipping restart"
        fi

    - name: Verify service health after restart
      if: steps.check_rotation.outputs.needs_rotation == 'true' && env.ROTATION_SUCCESS == 'true' && env.VERIFICATION_FAILED != 'true'
      run: |
        echo "üè• Checking service health after credential rotation..."
        
        # Wait a bit for service to start up
        sleep 30
        
        # Check if pods are ready
        if kubectl get deployment "$SERVICE" &> /dev/null; then
          ready_pods=$(kubectl get deployment "$SERVICE" -o jsonpath='{.status.readyReplicas}')
          desired_pods=$(kubectl get deployment "$SERVICE" -o jsonpath='{.spec.replicas}')
          
          if [ "$ready_pods" = "$desired_pods" ] && [ "$ready_pods" -gt 0 ]; then
            echo "‚úÖ All $ready_pods/$desired_pods pods are ready for $SERVICE"
          else
            echo "‚ùå Only $ready_pods/$desired_pods pods are ready for $SERVICE"
            kubectl describe deployment "$SERVICE"
            kubectl get pods -l app="$SERVICE"
            exit 1
          fi
        fi

    - name: Update audit log
      if: steps.check_rotation.outputs.needs_rotation == 'true'
      run: |
        # Log the rotation event in the database
        result="success"
        if [ "$ROTATION_SUCCESS" != "true" ] || [ "$VERIFICATION_FAILED" = "true" ]; then
          result="failed"
        fi
        
        PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" << EOF
INSERT INTO permission_audit_log (user_id, action, result, context, created_at)
VALUES (
  '00000000-0000-0000-0000-000000000000'::UUID,
  'credential_rotation',
  '$result',
  jsonb_build_object(
    'service_name', '$SERVICE',
    'environment', '$ENVIRONMENT',
    'automation', 'ci_cd',
    'workflow_run_id', '${{ github.run_id }}',
    'triggered_by', '${{ github.event_name }}'
  ),
  NOW()
);
EOF

    - name: Clean up backup files
      if: steps.check_rotation.outputs.needs_rotation == 'true' && env.ROTATION_SUCCESS == 'true' && env.VERIFICATION_FAILED != 'true'
      run: |
        # Remove backup files after successful rotation
        rm -f ${SERVICE}_backup_*.csv
        rm -f ${SERVICE}_secrets_backup_*.json
        rm -f ${SERVICE}_k8s_backup_*.yaml
        rm -f token_response.json

    - name: Upload backup files on failure
      if: failure() && steps.check_rotation.outputs.needs_rotation == 'true'
      uses: actions/upload-artifact@v3
      with:
        name: rotation-backup-${{ matrix.environment }}-${{ matrix.service }}-${{ github.run_id }}
        path: |
          ${{ matrix.service }}_backup_*.csv
          ${{ matrix.service }}_secrets_backup_*.json
          ${{ matrix.service }}_k8s_backup_*.yaml
        retention-days: 7

    - name: Notify on success
      if: steps.check_rotation.outputs.needs_rotation == 'true' && env.ROTATION_SUCCESS == 'true' && env.VERIFICATION_FAILED != 'true'
      run: |
        echo "‚úÖ Credential rotation completed successfully for $SERVICE in $ENVIRONMENT"
        
        # Optional: Send notification
        if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"üîÑ Credentials rotated successfully for '"$SERVICE"' in '"$ENVIRONMENT"' environment"}' \
            "${{ secrets.SLACK_WEBHOOK_URL }}"
        fi

    - name: Notify on failure
      if: failure() && steps.check_rotation.outputs.needs_rotation == 'true'
      run: |
        echo "‚ùå Credential rotation failed for $SERVICE in $ENVIRONMENT"
        
        # Send alert notification
        if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"üö® ALERT: Credential rotation FAILED for '"$SERVICE"' in '"$ENVIRONMENT"' environment. Manual intervention required! Check GitHub Actions run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"}' \
            "${{ secrets.SLACK_WEBHOOK_URL }}"
        fi
        
        # Optional: Create incident ticket
        if [ -n "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}" ]; then
          curl -X POST https://events.pagerduty.com/v2/enqueue \
            -H 'Content-Type: application/json' \
            -d '{
              "routing_key": "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}",
              "event_action": "trigger",
              "payload": {
                "summary": "Service credential rotation failed for '"$SERVICE"' in '"$ENVIRONMENT"'",
                "severity": "warning",
                "source": "github-actions",
                "custom_details": {
                  "service": "'"$SERVICE"'",
                  "environment": "'"$ENVIRONMENT"'",
                  "workflow_run": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                }
              }
            }'
        fi

  summary:
    needs: rotate-credentials
    runs-on: ubuntu-latest
    if: always()
    steps:
    - name: Generate summary report
      run: |
        echo "# Credential Rotation Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
        echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Count successes and failures
        success_count=0
        failure_count=0
        
        # This is a simplified count - in a real scenario, you'd parse the job results
        total_jobs="${{ strategy.matrix.environment.length * strategy.matrix.service.length }}"
        echo "**Total rotation jobs:** $total_jobs" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.rotate-credentials.result }}" = "success" ]; then
          echo "‚úÖ **All credential rotations completed successfully**" >> $GITHUB_STEP_SUMMARY
        else
          echo "‚ö†Ô∏è **Some credential rotations failed - check individual job logs**" >> $GITHUB_STEP_SUMMARY
        fi