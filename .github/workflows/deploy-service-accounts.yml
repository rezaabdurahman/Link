name: Deploy Service Accounts

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
        - development
        - staging
        - production
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
        - setup
        - rotate
        - health-check
      service_name:
        description: 'Service name (required for rotate action)'
        required: false
        type: string

  push:
    branches: [main]
    paths:
    - 'backend/user-svc/migrations/009_service_accounts.up.sql'
    - 'scripts/setup-service-accounts.sh'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy-service-accounts:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'development' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Detect environment
      id: env
      uses: ./.github/actions/detect-environment
      with:
        override_environment: ${{ github.event.inputs.environment }}
        fallback_environment: 'development'
        
    - name: Set workflow variables
      run: |
        echo "ENVIRONMENT=${{ steps.env.outputs.environment }}" >> $GITHUB_ENV
        echo "ACTION=${{ github.event.inputs.action || 'setup' }}" >> $GITHUB_ENV
        echo "SERVICE_NAME=${{ github.event.inputs.service_name }}" >> $GITHUB_ENV

    - name: Configure AWS credentials
      if: env.ENVIRONMENT == 'production' || env.ENVIRONMENT == 'staging'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION || 'us-west-2' }}

    - name: Configure kubectl
      if: env.ENVIRONMENT != 'development'
      uses: azure/k8s-set-context@v3
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.KUBECONFIG }}

    - name: Install dependencies
      run: |
        # Install PostgreSQL client
        sudo apt-get update
        sudo apt-get install -y postgresql-client
        
        # Install htpasswd for password hashing
        sudo apt-get install -y apache2-utils
        
        # Install HashiCorp Vault CLI (if needed)
        if [ "${{ vars.SECRETS_BACKEND }}" == "vault" ]; then
          wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
          sudo apt-get update && sudo apt-get install -y vault
        fi

    - name: Set database connection variables
      run: |
        case "$ENVIRONMENT" in
          "production")
            echo "DB_HOST=${{ secrets.PROD_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.PROD_DB_PORT || '5432' }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.PROD_DB_NAME }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.PROD_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "SECRETS_BACKEND=${{ vars.PROD_SECRETS_BACKEND || 'aws' }}" >> $GITHUB_ENV
            ;;
          "staging")
            echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}" >> $GITHUB_ENV
            echo "DB_PORT=${{ secrets.STAGING_DB_PORT || '5432' }}" >> $GITHUB_ENV
            echo "DB_NAME=${{ secrets.STAGING_DB_NAME }}" >> $GITHUB_ENV
            echo "DB_USER=${{ secrets.STAGING_DB_USER }}" >> $GITHUB_ENV
            echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_ENV
            echo "SECRETS_BACKEND=${{ vars.STAGING_SECRETS_BACKEND || 'kubernetes' }}" >> $GITHUB_ENV
            ;;
          "development")
            echo "DB_HOST=localhost" >> $GITHUB_ENV
            echo "DB_PORT=5432" >> $GITHUB_ENV
            echo "DB_NAME=linkdb" >> $GITHUB_ENV
            echo "DB_USER=link_user" >> $GITHUB_ENV
            echo "DB_PASSWORD=linkpass" >> $GITHUB_ENV
            echo "SECRETS_BACKEND=env" >> $GITHUB_ENV
            ;;
        esac

    - name: Setup PostgreSQL for development
      if: env.ENVIRONMENT == 'development'
      run: |
        # Start PostgreSQL
        sudo systemctl start postgresql
        sudo systemctl enable postgresql
        
        # Create database and user
        sudo -u postgres createuser --createdb --login link_user || true
        sudo -u postgres psql -c "ALTER USER link_user PASSWORD 'linkpass';" || true
        sudo -u postgres createdb -O link_user linkdb || true

    - name: Run database migrations
      if: env.ACTION == 'setup'
      run: |
        # Run the service accounts migration if it hasn't been run
        PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "
        CREATE TABLE IF NOT EXISTS migration_history (
          id SERIAL PRIMARY KEY,
          migration_name VARCHAR(255) NOT NULL UNIQUE,
          applied_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        );
        
        INSERT INTO migration_history (migration_name)
        SELECT '009_service_accounts.up.sql'
        WHERE NOT EXISTS (
          SELECT 1 FROM migration_history WHERE migration_name = '009_service_accounts.up.sql'
        );
        "
        
        # Run the migration if not already applied
        if PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c "
          SELECT EXISTS(SELECT 1 FROM migration_history WHERE migration_name = '009_service_accounts.up.sql');
        " | grep -q 't'; then
          echo "Service accounts migration already applied"
        else
          echo "Applying service accounts migration..."
          PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -f backend/user-svc/migrations/009_service_accounts.up.sql
        fi

    - name: Make setup script executable
      run: chmod +x scripts/setup-service-accounts.sh

    - name: Execute service account action
      run: |
        case "$ACTION" in
          "setup")
            ./scripts/setup-service-accounts.sh setup
            ;;
          "rotate")
            if [ -z "$SERVICE_NAME" ]; then
              echo "Service name is required for rotate action"
              exit 1
            fi
            ./scripts/setup-service-accounts.sh rotate "$SERVICE_NAME"
            ;;
          "health-check")
            ./scripts/setup-service-accounts.sh health-check
            ;;
        esac

    - name: Generate and apply Kubernetes manifests
      if: env.ACTION == 'setup' && env.ENVIRONMENT != 'development'
      run: |
        # Generate manifests
        ./scripts/setup-service-accounts.sh generate-manifests
        
        # Apply manifests to Kubernetes
        for manifest in k8s/*-deployment-with-service-auth.yaml; do
          if [ -f "$manifest" ]; then
            echo "Applying $manifest..."
            kubectl apply -f "$manifest"
          fi
        done

    - name: Verify deployment
      if: env.ACTION == 'setup' && env.ENVIRONMENT != 'development'
      run: |
        echo "Waiting for deployments to be ready..."
        for service in user-svc chat-svc ai-svc discovery-svc search-svc; do
          if kubectl get deployment "$service" &> /dev/null; then
            kubectl rollout status deployment/"$service" --timeout=300s
            echo "✅ $service deployment is ready"
          fi
        done

    - name: Run health check
      run: ./scripts/setup-service-accounts.sh health-check

    - name: Upload artifacts
      if: env.ACTION == 'setup'
      uses: actions/upload-artifact@v3
      with:
        name: service-account-manifests-${{ env.ENVIRONMENT }}
        path: |
          k8s/*-deployment-with-service-auth.yaml
          backend/*/.env.service-account
        retention-days: 30

    - name: Notify on success
      if: success()
      run: |
        echo "✅ Service account $ACTION completed successfully for $ENVIRONMENT environment"
        
        # Optional: Send Slack notification
        if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"✅ Service accounts '"$ACTION"' completed successfully in '"$ENVIRONMENT"' environment"}' \
            "${{ secrets.SLACK_WEBHOOK_URL }}"
        fi

    - name: Notify on failure
      if: failure()
      run: |
        echo "❌ Service account $ACTION failed for $ENVIRONMENT environment"
        
        # Optional: Send Slack notification
        if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"❌ Service accounts '"$ACTION"' failed in '"$ENVIRONMENT"' environment. Check GitHub Actions for details."}' \
            "${{ secrets.SLACK_WEBHOOK_URL }}"
        fi

  # Separate job for credential rotation on schedule
  scheduled-rotation:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    strategy:
      matrix:
        environment: [staging, production]
        service: [user-svc, chat-svc, ai-svc, discovery-svc, search-svc]
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure environment
      run: echo "ENVIRONMENT=${{ matrix.environment }}" >> $GITHUB_ENV

    - name: Setup dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y postgresql-client apache2-utils

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION || 'us-west-2' }}

    - name: Configure kubectl
      uses: azure/k8s-set-context@v3
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.KUBECONFIG }}

    - name: Set database connection
      run: |
        if [ "${{ matrix.environment }}" == "production" ]; then
          echo "DB_HOST=${{ secrets.PROD_DB_HOST }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}" >> $GITHUB_ENV
          echo "SECRETS_BACKEND=aws" >> $GITHUB_ENV
        else
          echo "DB_HOST=${{ secrets.STAGING_DB_HOST }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_ENV
          echo "SECRETS_BACKEND=kubernetes" >> $GITHUB_ENV
        fi

    - name: Rotate service credentials
      run: |
        chmod +x scripts/setup-service-accounts.sh
        ./scripts/setup-service-accounts.sh rotate "${{ matrix.service }}"

    - name: Restart service deployment
      run: |
        # Trigger rolling restart to pick up new credentials
        kubectl rollout restart deployment/${{ matrix.service }}
        kubectl rollout status deployment/${{ matrix.service }} --timeout=300s