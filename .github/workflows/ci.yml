name: CI/CD Pipeline

on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]

env:
  NODE_VERSION: '18'
  GO_VERSION: '1.23'
  # Test environment variables (use GitHub Secrets with CI fallbacks)
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY || 'test-key-for-ci' }}
  SERVICE_AUTH_TOKEN: ${{ secrets.SERVICE_AUTH_TOKEN || 'test-service-token-for-ci' }}
  JWT_SECRET: ${{ secrets.JWT_SECRET || 'test-jwt-secret-for-ci-only' }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'ci_test_password' }}
  REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD || 'ci_redis_password' }}

jobs:
  backend-unit-tests:
    name: Backend Unit Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [api-gateway, chat-svc, discovery-svc, search-svc, user-svc]
        
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go ${{ env.GO_VERSION }}
      uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
    
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ matrix.service }}-${{ hashFiles(format('backend/{0}/go.sum', matrix.service)) }}
        restore-keys: |
          ${{ runner.os }}-go-${{ matrix.service }}-
          ${{ runner.os }}-go-
    
    - name: Run unit tests for ${{ matrix.service }}
      working-directory: backend/${{ matrix.service }}
      run: |
        go mod tidy
        go test -v -race -coverprofile=coverage.out ./...
        go tool cover -html=coverage.out -o coverage.html
        
    - name: Check test coverage
      working-directory: backend/${{ matrix.service }}
      run: |
        COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print substr($3, 1, length($3)-1)}')
        echo "Coverage for ${{ matrix.service }}: $COVERAGE%"
        if (( $(echo "$COVERAGE >= 60" | bc -l) )); then
          echo "‚úÖ Coverage requirement met: $COVERAGE% >= 60%"
        else
          echo "‚ùå Coverage requirement not met: $COVERAGE% < 60%"
          exit 1
        fi
    
    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      with:
        name: backend-coverage-${{ matrix.service }}
        path: backend/${{ matrix.service }}/coverage.html

  integration-tests:
    name: Backend Integration Tests
    runs-on: ubuntu-latest
    needs: [backend-unit-tests]
    
    services:
      postgres:
        image: pgvector/pgvector:pg15-v0.5.1
        env:
          POSTGRES_DB: link_app_test
          POSTGRES_USER: link_user
          POSTGRES_PASSWORD: link_pass
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
    
    - name: Wait for services
      run: |
        until pg_isready -h localhost -p 5432 -U link_user; do
          echo "Waiting for PostgreSQL..."
          sleep 2
        done
        
        until redis-cli -h localhost -p 6379 ping; do
          echo "Waiting for Redis..."
          sleep 2
        done
    
    - name: Build services
      working-directory: backend
      run: docker-compose build --parallel
    
    - name: Run integration tests
      working-directory: backend
      run: |
        export OPENAI_API_KEY="$OPENAI_API_KEY"
        export SERVICE_AUTH_TOKEN="$SERVICE_AUTH_TOKEN"
        ./integration-tests.sh
      timeout-minutes: 15
    
    - name: Collect service logs on failure
      if: failure()
      working-directory: backend
      run: |
        echo "=== Service Status ==="
        docker-compose ps
        echo "=== API Gateway Logs ==="
        docker-compose logs api-gateway
        echo "=== User Service Logs ==="
        docker-compose logs user-svc
        echo "=== Discovery Service Logs ==="
        docker-compose logs discovery-svc
        echo "=== Search Service Logs ==="
        docker-compose logs search-svc
    
    - name: Cleanup
      if: always()
      working-directory: backend
      run: docker-compose down -v

  lint-and-typecheck:
    name: Lint & Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'frontend/package-lock.json'
      - name: Install dependencies
        working-directory: frontend
        run: npm ci
      - name: Run ESLint
        working-directory: frontend
        run: npm run lint
      - name: Run TypeScript check
        working-directory: frontend
        run: npm run type-check

  test:
    name: Frontend Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'frontend/package-lock.json'
      - name: Install dependencies
        working-directory: frontend
        run: npm ci
      - name: Setup test environment
        working-directory: frontend
        run: |
          cp .env.test.example .env.test
          echo "NODE_ENV=test" >> .env.test
        env:
          NODE_ENV: test
      - name: Run tests with coverage (relaxed thresholds for now)
        working-directory: frontend
        run: npm run test:coverage:ci
        env:
          NODE_ENV: test
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./frontend/coverage/lcov.info
          fail_ci_if_error: false
          directory: ./frontend
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  build:
    name: Build Frontend
    needs: [lint-and-typecheck, test, integration-tests]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        mode: [demo, preview, production]
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'frontend/package-lock.json'
      - name: Install dependencies
        working-directory: frontend
        run: npm ci
      - name: Build (${{ matrix.mode }})
        working-directory: frontend
        run: npm run build:${{ matrix.mode }}
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.mode }}
          path: frontend/dist
          retention-days: 7

  security-audit:
    name: Frontend Security Audit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'frontend/package-lock.json'
      - name: Install dependencies
        working-directory: frontend
        run: npm ci
      - name: npm audit
        working-directory: frontend
        run: npm audit --audit-level=high || true

  dependency-review:
    name: Dependency Review (PR only)
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: moderate

  secret-scanning:
    name: Secret Scanning (PR only)
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for gitleaks
      
      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }} # Only needed for Gitleaks-Pro
      
      - name: Check for hardcoded patterns
        run: |
          echo "üîç Checking for additional hardcoded patterns..."
          
          # Check for obvious hardcoded secrets
          if grep -r -n --include="*.env*" --exclude="*.example*" -E "(password|secret|key).*=.*[a-zA-Z0-9]{8,}" . | grep -v "\${\|your_\|change_this\|example\|template"; then
            echo "‚ùå Found potential hardcoded secrets!"
            exit 1
          fi
          
          # Check for TODO comments about secrets
          if grep -r -n --include="*.go" --include="*.ts" --include="*.js" -i "TODO.*secret\|FIXME.*password\|HACK.*key" .; then
            echo "‚ö†Ô∏è Found TODO comments about secrets - review needed"
          fi
          
          echo "‚úÖ No obvious hardcoded secrets found"

  warp-indexing-check:
    name: Warp AI Indexing Optimization Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Count total files
        id: file-count
        run: |
          TOTAL_FILES=$(find . -type f | wc -l)
          echo "total_files=$TOTAL_FILES" >> $GITHUB_OUTPUT
          echo "Total files in repository: $TOTAL_FILES"
      
      - name: Count files that would be indexed by AI
        id: indexed-count
        run: |
          # Simulate .warpignore filtering (approximate)
          INDEXED_FILES=$(find . -type f | \
            grep -v -E "(node_modules|Link-|coverage|\.git|dist|build|out|\.log$|\.tmp$|vendor)" | \
            grep -v -E "\.(md|png|jpg|jpeg|gif|svg|mp4|avi|mov|webm|ico)$" | \
            wc -l)
          echo "indexed_files=$INDEXED_FILES" >> $GITHUB_OUTPUT
          echo "Files that would be indexed: $INDEXED_FILES"
      
      - name: Calculate indexing efficiency
        run: |
          TOTAL=${{ steps.file-count.outputs.total_files }}
          INDEXED=${{ steps.indexed-count.outputs.indexed_files }}
          PERCENTAGE=$(( (INDEXED * 100) / TOTAL ))
          echo "Indexing efficiency: $INDEXED / $TOTAL files ($PERCENTAGE%)"
          
          # Fail if more than 5% of files would be indexed (indicating bloat)
          if [ $PERCENTAGE -gt 5 ]; then
            echo "‚ùå Too many files would be indexed ($PERCENTAGE%). Expected ‚â§5%."
            echo "This indicates potential repository bloat affecting AI performance."
            echo "Consider updating .warpignore or removing unnecessary files."
            exit 1
          else
            echo "‚úÖ Indexing efficiency is optimal ($PERCENTAGE% ‚â§ 5%)"
          fi
      
      - name: Verify .warpignore exists
        run: |
          if [ ! -f .warpignore ]; then
            echo "‚ùå .warpignore file not found!"
            echo "AI indexing optimization requires a .warpignore file."
            exit 1
          else
            echo "‚úÖ .warpignore file exists"
          fi

  deploy-staging:
    name: Deploy Staging
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    needs: [build, security-audit, integration-tests]
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: build-preview
          path: ./dist
      - name: Deploy to staging
        run: echo "Deploy staging step ‚Äì add your commands here"

  deploy-production:
    name: Deploy Production
    if: github.event_name == 'release' && github.event.action == 'published'
    needs: [build, security-audit, integration-tests]
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: build-production
          path: ./dist
      - name: Deploy to production
        run: echo "Deploy production step ‚Äì add your commands here"
