name: Monitoring Stack Deployment & Validation

on:
  push:
    branches: [main, master]
    paths:
      - 'monitoring/**'
      - 'backend/**/internal/middleware/metrics.go'
      - 'backend/shared-libs/metrics/**'
  pull_request:
    branches: [main, master]
    paths:
      - 'monitoring/**'
      - 'backend/**/internal/middleware/metrics.go'
      - 'backend/shared-libs/metrics/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy monitoring to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  validate-monitoring-configs:
    name: Validate Monitoring Configuration
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Validate Prometheus Config
      run: |
        # Use official Prometheus image to validate config
        docker run --rm -v $(pwd)/monitoring/prometheus:/etc/prometheus \
          prom/prometheus:latest \
          --config.file=/etc/prometheus/prometheus.yml \
          --dry-run 2>&1 | tee prometheus-validation.log
        
        # Check if validation passed
        if grep -q "error" prometheus-validation.log; then
          echo "‚ùå Prometheus configuration validation failed"
          cat prometheus-validation.log
          exit 1
        else
          echo "‚úÖ Prometheus configuration is valid"
        fi

    - name: Validate AlertManager Config
      run: |
        # Validate AlertManager configurations for all environments
        for config in monitoring/alertmanager/*.yml; do
          echo "Validating $config..."
          docker run --rm -v $(pwd)/$config:/etc/alertmanager/alertmanager.yml \
            prom/alertmanager:latest \
            --config.file=/etc/alertmanager/alertmanager.yml \
            --config.check 2>&1 | tee alertmanager-validation.log
          
          if grep -q "error\|Error" alertmanager-validation.log; then
            echo "‚ùå AlertManager config validation failed for $config"
            cat alertmanager-validation.log
            exit 1
          else
            echo "‚úÖ AlertManager config is valid for $config"
          fi
        done

    - name: Validate Loki Config
      run: |
        # Validate Loki configurations
        for config in monitoring/loki/*.yaml; do
          echo "Validating $config..."
          docker run --rm -v $(pwd)/$config:/etc/loki/local-config.yaml \
            grafana/loki:2.9.0 \
            -config.file=/etc/loki/local-config.yaml \
            -verify-config 2>&1 | tee loki-validation.log || true
          
          # Loki validation output varies, check for critical errors
          if grep -q "level=error\|panic\|fatal" loki-validation.log; then
            echo "‚ùå Loki config validation failed for $config"
            cat loki-validation.log
            exit 1
          else
            echo "‚úÖ Loki config is valid for $config"
          fi
        done

    - name: Validate Promtail Config  
      run: |
        # Validate Promtail configurations
        for config in monitoring/promtail*.yml; do
          echo "Validating $config..."
          docker run --rm -v $(pwd)/$config:/etc/promtail/config.yml \
            grafana/promtail:2.9.0 \
            -config.file=/etc/promtail/config.yml \
            -dry-run 2>&1 | tee promtail-validation.log || true
          
          if grep -q "error\|Error\|panic" promtail-validation.log; then
            echo "‚ùå Promtail config validation failed for $config"
            cat promtail-validation.log
            exit 1
          else
            echo "‚úÖ Promtail config is valid for $config"
          fi
        done

    - name: Validate Alert Rules
      run: |
        # Validate Prometheus alert rules
        docker run --rm -v $(pwd)/monitoring/prometheus/rules:/etc/prometheus/rules \
          prom/prometheus:latest \
          --config.file=<(cat <<EOF
        global:
          scrape_interval: 15s
        rule_files:
          - "/etc/prometheus/rules/*.yml"
        scrape_configs:
          - job_name: 'prometheus'
            static_configs:
              - targets: ['localhost:9090']
        EOF
        ) --dry-run 2>&1 | tee rules-validation.log
        
        if grep -q "error\|Error" rules-validation.log; then
          echo "‚ùå Alert rules validation failed"
          cat rules-validation.log
          exit 1
        else
          echo "‚úÖ Alert rules are valid"
        fi

  test-metrics-endpoints:
    name: Test Metrics Endpoints
    runs-on: ubuntu-latest
    needs: validate-monitoring-configs
    
    strategy:
      matrix:
        service: [api-gateway, user-svc, chat-svc, discovery-svc, search-svc, ai-svc]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.23'
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Setup test environment
      run: |
        # Start minimal test infrastructure
        docker-compose -f backend/docker-compose.yml up -d postgres redis-user redis-chat redis-discovery redis-gateway
        
        # Wait for services to be ready
        timeout 60 bash -c 'until docker-compose -f backend/docker-compose.yml ps | grep -q "healthy\|Up"; do sleep 2; done'

    - name: Build and start ${{ matrix.service }}
      working-directory: backend/${{ matrix.service }}
      run: |
        # Build service
        if [ -f "go.mod" ]; then
          go mod tidy
          go build -o service .
          
          # Start service in background
          ./service &
          SERVICE_PID=$!
          echo "SERVICE_PID=$SERVICE_PID" >> $GITHUB_ENV
          
          # Wait for service to start
          timeout 30 bash -c 'until curl -s http://localhost:8080/health > /dev/null; do sleep 1; done' || \
          timeout 30 bash -c 'until curl -s http://localhost:8081/health > /dev/null; do sleep 1; done' || \
          timeout 30 bash -c 'until curl -s http://localhost:8083/health > /dev/null; do sleep 1; done' || \
          timeout 30 bash -c 'until curl -s http://localhost:8085/health > /dev/null; do sleep 1; done' || \
          echo "Service health check timeout (this may be expected for some services)"
        fi

    - name: Test metrics endpoint for ${{ matrix.service }}
      run: |
        # Test different possible ports where service might be running
        PORTS=(8080 8081 8083 8085)
        METRICS_FOUND=false
        
        for port in "${PORTS[@]}"; do
          echo "Testing metrics endpoint on port $port..."
          
          # Test if /metrics endpoint exists and returns valid Prometheus format
          if curl -s "http://localhost:$port/metrics" > metrics_output.txt; then
            # Check if output contains Prometheus metrics
            if grep -q "^# HELP\|^# TYPE" metrics_output.txt && grep -q "_total\|_duration\|_active" metrics_output.txt; then
              echo "‚úÖ Valid metrics found on port $port for ${{ matrix.service }}"
              
              # Validate specific metrics exist
              echo "Validating service-specific metrics..."
              
              case "${{ matrix.service }}" in
                "api-gateway")
                  if grep -q "api_gateway_http_requests_total\|gateway_" metrics_output.txt; then
                    echo "‚úÖ API Gateway metrics validated"
                    METRICS_FOUND=true
                  fi
                  ;;
                "user-svc")
                  if grep -q "user_svc_http_requests_total\|user_" metrics_output.txt; then
                    echo "‚úÖ User service metrics validated"
                    METRICS_FOUND=true
                  fi
                  ;;
                "chat-svc")
                  if grep -q "chat_svc_http_requests_total\|chat_svc_messages_total" metrics_output.txt; then
                    echo "‚úÖ Chat service metrics validated"
                    METRICS_FOUND=true
                  fi
                  ;;
                "discovery-svc")
                  if grep -q "discovery_svc_http_requests_total\|discovery_svc_broadcasts_total" metrics_output.txt; then
                    echo "‚úÖ Discovery service metrics validated"
                    METRICS_FOUND=true
                  fi
                  ;;
                "search-svc")
                  if grep -q "search_svc_http_requests_total\|search_svc_queries_total" metrics_output.txt; then
                    echo "‚úÖ Search service metrics validated"
                    METRICS_FOUND=true
                  fi
                  ;;
                "ai-svc")
                  if grep -q "ai_svc_http_requests_total\|ai_svc_ai_requests_total" metrics_output.txt; then
                    echo "‚úÖ AI service metrics validated"
                    METRICS_FOUND=true
                  fi
                  ;;
              esac
              
              break
            fi
          fi
        done
        
        if [ "$METRICS_FOUND" = false ]; then
          echo "‚ùå No valid metrics endpoint found for ${{ matrix.service }}"
          echo "Metrics output sample:"
          head -20 metrics_output.txt || echo "No metrics output captured"
          exit 1
        fi

    - name: Cleanup
      if: always()
      run: |
        # Kill service if it was started
        if [ -n "$SERVICE_PID" ]; then
          kill $SERVICE_PID || true
        fi
        
        # Stop infrastructure
        docker-compose -f backend/docker-compose.yml down || true

  deploy-monitoring-staging:
    name: Deploy Monitoring to Staging
    runs-on: ubuntu-latest
    needs: [validate-monitoring-configs, test-metrics-endpoints]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup environment variables
      run: |
        echo "GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD }}" >> .env.monitoring
        echo "SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL }}" >> .env.monitoring
        echo "SMTP_HOST=${{ secrets.SMTP_HOST }}" >> .env.monitoring
        echo "SMTP_USER=${{ secrets.SMTP_USER }}" >> .env.monitoring
        echo "SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}" >> .env.monitoring

    - name: Deploy monitoring stack to staging
      run: |
        echo "üöÄ Deploying monitoring stack to staging..."
        
        # This would typically deploy to your staging infrastructure
        # For now, we'll validate the deployment command
        
        # Validate the deployment files exist
        ls -la monitoring/
        
        echo "‚úÖ Monitoring deployment validated for staging"
        echo "Command that would be executed:"
        echo "docker-compose -f monitoring/docker-compose.monitoring.yml -f monitoring/docker-compose.staging.yml up -d"

    - name: Validate deployment
      run: |
        echo "üîç Validating monitoring stack deployment..."
        
        # In a real deployment, this would check if services are healthy
        echo "Health checks that would be performed:"
        echo "- Prometheus: http://prometheus-staging.yourdomain.com/-/healthy"
        echo "- Grafana: http://grafana-staging.yourdomain.com/api/health"
        echo "- AlertManager: http://alertmanager-staging.yourdomain.com/-/healthy"
        echo "- Loki: http://loki-staging.yourdomain.com/ready"
        
        echo "‚úÖ Monitoring deployment validation complete"

  deploy-monitoring-production:
    name: Deploy Monitoring to Production
    runs-on: ubuntu-latest
    needs: [validate-monitoring-configs, test-metrics-endpoints]
    if: github.event.inputs.environment == 'production'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup production environment variables
      run: |
        echo "GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD_PROD }}" >> .env.monitoring.prod
        echo "SLACK_WEBHOOK_URL=${{ secrets.SLACK_WEBHOOK_URL_PROD }}" >> .env.monitoring.prod
        echo "SECURITY_SLACK_WEBHOOK=${{ secrets.SECURITY_SLACK_WEBHOOK }}" >> .env.monitoring.prod
        echo "PAGERDUTY_ROUTING_KEY=${{ secrets.PAGERDUTY_ROUTING_KEY }}" >> .env.monitoring.prod
        echo "PHONE_ALERT_WEBHOOK=${{ secrets.PHONE_ALERT_WEBHOOK }}" >> .env.monitoring.prod
        echo "SMTP_HOST=${{ secrets.SMTP_HOST_PROD }}" >> .env.monitoring.prod
        echo "SMTP_USER=${{ secrets.SMTP_USER_PROD }}" >> .env.monitoring.prod
        echo "SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD_PROD }}" >> .env.monitoring.prod

    - name: Deploy monitoring stack to production
      run: |
        echo "üöÄ Deploying monitoring stack to production..."
        
        # Production deployment would go here
        echo "Production deployment command:"
        echo "docker-compose -f monitoring/docker-compose.monitoring.yml -f monitoring/docker-compose.production.yml up -d"
        
        echo "‚ö†Ô∏è Production deployment requires manual approval and would be executed by infrastructure team"

    - name: Validate production deployment
      run: |
        echo "üîç Validating production monitoring deployment..."
        
        # Production health checks would go here
        echo "Production health checks that would be performed:"
        echo "- Prometheus: https://prometheus.yourdomain.com/-/healthy"
        echo "- Grafana: https://grafana.yourdomain.com/api/health" 
        echo "- AlertManager: https://alertmanager.yourdomain.com/-/healthy"
        echo "- Loki: https://loki.yourdomain.com/ready"
        
        echo "‚úÖ Production monitoring deployment validation complete"