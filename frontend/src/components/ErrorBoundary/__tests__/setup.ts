// Test setup for error boundary tests\nimport '@testing-library/jest-dom';\nimport { jest } from '@jest/globals';\n\n// Mock window.performance\nObject.defineProperty(window, 'performance', {\n  value: {\n    timing: {\n      navigationStart: Date.now(),\n      loadEventEnd: Date.now() + 1000,\n      domContentLoadedEventEnd: Date.now() + 500\n    },\n    memory: {\n      usedJSHeapSize: 1000000,\n      jsHeapSizeLimit: 10000000\n    },\n    getEntriesByType: jest.fn().mockReturnValue([\n      { name: 'first-paint', startTime: 100 },\n      { name: 'first-contentful-paint', startTime: 150 }\n    ])\n  },\n  writable: true\n});\n\n// Mock navigator properties\nObject.defineProperty(navigator, 'onLine', {\n  value: true,\n  writable: true\n});\n\nObject.defineProperty(navigator, 'userAgent', {\n  value: 'Mozilla/5.0 (Test Environment) TestKit/1.0',\n  writable: true\n});\n\nObject.defineProperty(navigator, 'connection', {\n  value: {\n    effectiveType: '4g',\n    downlink: 10,\n    rtt: 100\n  },\n  writable: true\n});\n\n// Mock window.location\nObject.defineProperty(window, 'location', {\n  value: {\n    href: 'http://localhost:3000/test',\n    pathname: '/test',\n    search: '',\n    hash: '',\n    reload: jest.fn()\n  },\n  writable: true\n});\n\n// Mock localStorage and sessionStorage\nconst createStorageMock = () => {\n  const storage: Record<string, string> = {};\n  return {\n    getItem: jest.fn((key: string) => storage[key] || null),\n    setItem: jest.fn((key: string, value: string) => {\n      storage[key] = value;\n    }),\n    removeItem: jest.fn((key: string) => {\n      delete storage[key];\n    }),\n    clear: jest.fn(() => {\n      Object.keys(storage).forEach(key => delete storage[key]);\n    })\n  };\n};\n\nObject.defineProperty(window, 'localStorage', {\n  value: createStorageMock()\n});\n\nObject.defineProperty(window, 'sessionStorage', {\n  value: createStorageMock()\n});\n\n// Mock console methods to reduce noise in tests\nconst originalConsoleError = console.error;\nconst originalConsoleWarn = console.warn;\nconst originalConsoleLog = console.log;\n\nbeforeEach(() => {\n  console.error = jest.fn();\n  console.warn = jest.fn();\n  console.log = jest.fn();\n});\n\nafterEach(() => {\n  console.error = originalConsoleError;\n  console.warn = originalConsoleWarn;\n  console.log = originalConsoleLog;\n});\n\n// Mock caches API\nObject.defineProperty(window, 'caches', {\n  value: {\n    keys: jest.fn().mockResolvedValue(['cache1', 'cache2']),\n    delete: jest.fn().mockResolvedValue(true)\n  },\n  writable: true\n});\n\n// Mock import.meta.env\nObject.defineProperty(import.meta, 'env', {\n  value: {\n    NODE_ENV: 'test',\n    VITE_APP_VERSION: '1.0.0-test',\n    VITE_SENTRY_DSN: 'https://test@sentry.io/123456',\n    VITE_SENTRY_ENVIRONMENT: 'test'\n  },\n  writable: true\n});\n\n// Global test utilities\nglobal.createMockError = (message: string, type: string = 'Error') => {\n  const error = new Error(message);\n  error.name = type;\n  error.stack = `${type}: ${message}\\n    at test (test.js:1:1)`;\n  return error;\n};\n\nglobal.createMockErrorInfo = (componentStack?: string) => ({\n  componentStack: componentStack || 'Component stack trace'\n});\n\n// Mock ResizeObserver\nglobal.ResizeObserver = jest.fn().mockImplementation(() => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}));\n\n// Mock IntersectionObserver\nglobal.IntersectionObserver = jest.fn().mockImplementation(() => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}));\n\n// Setup custom matchers\nexpect.extend({\n  toBeErrorBoundaryCompliant(received) {\n    const pass = received && \n                 typeof received.componentDidCatch === 'function' &&\n                 typeof received.getDerivedStateFromError === 'function';\n                 \n    return {\n      message: () => pass \n        ? `Expected ${received} not to be error boundary compliant`\n        : `Expected ${received} to be error boundary compliant`,\n      pass\n    };\n  },\n  \n  toHaveErrorMetadata(received, expectedProperties) {\n    const hasRequiredProperties = expectedProperties.every(\n      (prop: string) => received && received[prop] !== undefined\n    );\n    \n    return {\n      message: () => hasRequiredProperties\n        ? `Expected error metadata not to have properties ${expectedProperties.join(', ')}`\n        : `Expected error metadata to have properties ${expectedProperties.join(', ')}`,\n      pass: hasRequiredProperties\n    };\n  }\n});\n\n// Export test utilities\nexport const testUtils = {\n  createMockError: global.createMockError,\n  createMockErrorInfo: global.createMockErrorInfo,\n  \n  // Helper to trigger async errors\n  triggerAsyncError: (error: Error) => {\n    const event = new CustomEvent('unhandledrejection', {\n      detail: { reason: error, promise: Promise.reject(error) }\n    }) as any;\n    event.reason = error;\n    event.promise = Promise.reject(error);\n    window.dispatchEvent(event);\n  },\n  \n  // Helper to trigger global errors\n  triggerGlobalError: (error: Error, filename = 'test.js', lineno = 1, colno = 1) => {\n    const event = new ErrorEvent('error', {\n      error,\n      message: error.message,\n      filename,\n      lineno,\n      colno\n    });\n    window.dispatchEvent(event);\n  },\n  \n  // Helper to mock network conditions\n  mockNetworkCondition: (online: boolean) => {\n    Object.defineProperty(navigator, 'onLine', {\n      value: online,\n      writable: true\n    });\n  },\n  \n  // Helper to wait for async operations\n  waitForAsync: () => new Promise(resolve => setTimeout(resolve, 0)),\n  \n  // Helper to create mock recovery strategy\n  createMockRecoveryStrategy: (type: string = 'retry', action?: Function) => ({\n    type,\n    label: `${type.charAt(0).toUpperCase()}${type.slice(1)} Action`,\n    description: `Perform ${type} action`,\n    action: action || jest.fn().mockResolvedValue(undefined),\n    priority: 1\n  })\n};\n\n// Declare global types for TypeScript\ndeclare global {\n  function createMockError(message: string, type?: string): Error;\n  function createMockErrorInfo(componentStack?: string): any;\n  \n  namespace jest {\n    interface Matchers<R> {\n      toBeErrorBoundaryCompliant(): R;\n      toHaveErrorMetadata(properties: string[]): R;\n    }\n  }\n}\n\nexport default testUtils;