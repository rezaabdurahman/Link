import React from 'react';\nimport { render, screen, fireEvent, waitFor, act } from '@testing-library/react';\nimport { jest } from '@jest/globals';\nimport '@testing-library/jest-dom';\nimport { GlobalErrorBoundary } from '../GlobalErrorBoundary';\nimport { RouteErrorBoundary } from '../RouteErrorBoundary';\nimport { AsyncErrorBoundary, useAsyncError } from '../AsyncErrorBoundary';\nimport { BrowserRouter } from 'react-router-dom';\nimport * as Sentry from '@sentry/react';\n\n// Mock Sentry\njest.mock('@sentry/react', () => ({\n  withScope: jest.fn((callback) => callback({ setTag: jest.fn(), setContext: jest.fn(), setLevel: jest.fn() })),\n  captureException: jest.fn(),\n  addBreadcrumb: jest.fn(),\n  setUser: jest.fn(),\n  setMeasurement: jest.fn(),\n  captureMessage: jest.fn()\n}));\n\n// Mock error service\njest.mock('../../../services/errorService', () => ({\n  errorService: {\n    handleError: jest.fn().mockResolvedValue({\n      id: 'test-error-id',\n      type: 'runtime',\n      severity: 'medium',\n      timestamp: Date.now(),\n      userAgent: 'test-agent',\n      url: 'http://localhost',\n      fingerprint: 'test-fingerprint',\n      context: {},\n      retryCount: 0,\n      maxRetries: 3,\n      isRecoverable: true,\n      recoveryStrategies: [{\n        type: 'retry',\n        label: 'Try Again',\n        description: 'Retry the operation',\n        action: jest.fn(),\n        priority: 1\n      }],\n      tags: {}\n    }),\n    executeRecovery: jest.fn().mockResolvedValue(true),\n    setAnalytics: jest.fn()\n  }\n}));\n\n// Mock error utils\njest.mock('../../../utils/errorUtils', () => ({\n  createErrorMetadata: jest.fn().mockResolvedValue({\n    id: 'test-error-id',\n    type: 'runtime',\n    severity: 'medium',\n    timestamp: Date.now(),\n    recoveryStrategies: []\n  }),\n  collectErrorContext: jest.fn().mockResolvedValue({}),\n  reportError: jest.fn().mockResolvedValue(undefined)\n}));\n\n// Mock components\njest.mock('../ErrorFallbackUI', () => ({\n  ErrorFallbackUI: React.forwardRef<HTMLDivElement, any>((props, ref) => (\n    <div ref={ref} data-testid=\"error-fallback\">\n      <h1>Error occurred</h1>\n      <p>Error Type: {props.metadata?.type || 'unknown'}</p>\n      <button onClick={() => props.onRecoveryStrategy(props.metadata?.recoveryStrategies?.[0])}>Try Again</button>\n      <button onClick={props.onReload}>Reload</button>\n      {props.enableReporting && <button>Report</button>}\n    </div>\n  ))\n}));\n\njest.mock('../ErrorReportModal', () => ({\n  ErrorReportModal: ({ onSubmit, onClose }: any) => (\n    <div data-testid=\"error-report-modal\">\n      <button onClick={() => onSubmit('Test description', ['Step 1'])}>Submit Report</button>\n      <button onClick={onClose}>Close Modal</button>\n    </div>\n  )\n}));\n\n// Test components\nconst ThrowErrorComponent: React.FC<{ shouldThrow: boolean; errorMessage?: string }> = ({ shouldThrow, errorMessage = 'Test error' }) => {\n  if (shouldThrow) {\n    throw new Error(errorMessage);\n  }\n  return <div>No error</div>;\n};\n\nconst AsyncErrorComponent: React.FC = () => {\n  const throwAsyncError = useAsyncError();\n  \n  return (\n    <button onClick={() => throwAsyncError(new Error('Async error'))}>\n      Trigger Async Error\n    </button>\n  );\n};\n\ndescribe('GlobalErrorBoundary', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    // Suppress console errors for tests\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n    jest.spyOn(console, 'log').mockImplementation(() => {});\n  });\n\n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n\n  it('renders children when there is no error', () => {\n    render(\n      <GlobalErrorBoundary>\n        <div>Child component</div>\n      </GlobalErrorBoundary>\n    );\n\n    expect(screen.getByText('Child component')).toBeInTheDocument();\n  });\n\n  it('catches and displays error when child component throws', async () => {\n    render(\n      <GlobalErrorBoundary>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    expect(screen.getByText('Error occurred')).toBeInTheDocument();\n  });\n\n  it('calls error service when error occurs', async () => {\n    const { errorService } = require('../../../services/errorService');\n    \n    render(\n      <GlobalErrorBoundary>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(errorService.handleError).toHaveBeenCalled();\n    });\n  });\n\n  it('calls custom onError handler when provided', async () => {\n    const mockOnError = jest.fn();\n    \n    render(\n      <GlobalErrorBoundary onError={mockOnError}>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(mockOnError).toHaveBeenCalled();\n    });\n  });\n\n  it('displays retry button and handles retry action', async () => {\n    render(\n      <GlobalErrorBoundary>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    const retryButton = screen.getByText('Try Again');\n    expect(retryButton).toBeInTheDocument();\n\n    fireEvent.click(retryButton);\n\n    const { errorService } = require('../../../services/errorService');\n    await waitFor(() => {\n      expect(errorService.executeRecovery).toHaveBeenCalled();\n    });\n  });\n\n  it('displays reload button and handles reload action', async () => {\n    const mockReload = jest.fn();\n    Object.defineProperty(window, 'location', {\n      value: { reload: mockReload },\n      writable: true\n    });\n\n    render(\n      <GlobalErrorBoundary>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    const reloadButton = screen.getByText('Reload');\n    fireEvent.click(reloadButton);\n\n    expect(mockReload).toHaveBeenCalled();\n  });\n\n  it('shows custom fallback when provided', () => {\n    const CustomFallback = () => <div>Custom error UI</div>;\n    \n    render(\n      <GlobalErrorBoundary fallback={<CustomFallback />}>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    expect(screen.getByText('Custom error UI')).toBeInTheDocument();\n  });\n\n  it('shows reporting button when reporting is enabled', async () => {\n    render(\n      <GlobalErrorBoundary enableReporting={true}>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    expect(screen.getByText('Report')).toBeInTheDocument();\n  });\n});\n\ndescribe('RouteErrorBoundary', () => {\n  const RouterWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (\n    <BrowserRouter>{children}</BrowserRouter>\n  );\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  it('renders children when there is no error', () => {\n    render(\n      <RouterWrapper>\n        <RouteErrorBoundary>\n          <div>Route content</div>\n        </RouteErrorBoundary>\n      </RouterWrapper>\n    );\n\n    expect(screen.getByText('Route content')).toBeInTheDocument();\n  });\n\n  it('catches route-specific errors', async () => {\n    render(\n      <RouterWrapper>\n        <RouteErrorBoundary routeName=\"TestRoute\">\n          <ThrowErrorComponent shouldThrow={true} errorMessage=\"Route error\" />\n        </RouteErrorBoundary>\n      </RouterWrapper>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n  });\n\n  it('resets error state when route changes', async () => {\n    const { rerender } = render(\n      <RouterWrapper>\n        <RouteErrorBoundary routeName=\"Route1\">\n          <ThrowErrorComponent shouldThrow={true} />\n        </RouteErrorBoundary>\n      </RouterWrapper>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    // Simulate route change by rerendering with different content\n    rerender(\n      <RouterWrapper>\n        <RouteErrorBoundary routeName=\"Route2\">\n          <div>New route content</div>\n        </RouteErrorBoundary>\n      </RouterWrapper>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByText('New route content')).toBeInTheDocument();\n    });\n  });\n\n  it('calls onRecover when recovery is successful', async () => {\n    const mockOnRecover = jest.fn();\n    \n    render(\n      <RouterWrapper>\n        <RouteErrorBoundary onRecover={mockOnRecover}>\n          <ThrowErrorComponent shouldThrow={true} />\n        </RouteErrorBoundary>\n      </RouterWrapper>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    const retryButton = screen.getByText('Try Again');\n    fireEvent.click(retryButton);\n\n    await waitFor(() => {\n      expect(mockOnRecover).toHaveBeenCalled();\n    });\n  });\n});\n\ndescribe('AsyncErrorBoundary', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n    jest.spyOn(console, 'warn').mockImplementation(() => {});\n    \n    // Mock window event listeners\n    global.addEventListener = jest.fn();\n    global.removeEventListener = jest.fn();\n  });\n\n  it('renders children normally', () => {\n    render(\n      <AsyncErrorBoundary>\n        <div>Async content</div>\n      </AsyncErrorBoundary>\n    );\n\n    expect(screen.getByText('Async content')).toBeInTheDocument();\n  });\n\n  it('handles async errors from useAsyncError hook', async () => {\n    render(\n      <AsyncErrorBoundary>\n        <AsyncErrorComponent />\n      </AsyncErrorBoundary>\n    );\n\n    const triggerButton = screen.getByText('Trigger Async Error');\n    \n    act(() => {\n      fireEvent.click(triggerButton);\n    });\n\n    // Should not crash the component tree\n    expect(screen.getByText('Trigger Async Error')).toBeInTheDocument();\n  });\n\n  it('calls onError when async error occurs', async () => {\n    const mockOnError = jest.fn();\n    \n    render(\n      <AsyncErrorBoundary onError={mockOnError}>\n        <AsyncErrorComponent />\n      </AsyncErrorBoundary>\n    );\n\n    const triggerButton = screen.getByText('Trigger Async Error');\n    \n    act(() => {\n      fireEvent.click(triggerButton);\n    });\n\n    await waitFor(() => {\n      expect(mockOnError).toHaveBeenCalled();\n    }, { timeout: 100 });\n  });\n\n  it('sets up unhandled promise rejection listener', () => {\n    render(\n      <AsyncErrorBoundary>\n        <div>Test</div>\n      </AsyncErrorBoundary>\n    );\n\n    expect(global.addEventListener).toHaveBeenCalledWith(\n      'unhandledrejection', \n      expect.any(Function)\n    );\n    expect(global.addEventListener).toHaveBeenCalledWith(\n      'error', \n      expect.any(Function)\n    );\n  });\n\n  it('cleans up event listeners on unmount', () => {\n    const { unmount } = render(\n      <AsyncErrorBoundary>\n        <div>Test</div>\n      </AsyncErrorBoundary>\n    );\n\n    unmount();\n\n    expect(global.removeEventListener).toHaveBeenCalledWith(\n      'unhandledrejection', \n      expect.any(Function)\n    );\n    expect(global.removeEventListener).toHaveBeenCalledWith(\n      'error', \n      expect.any(Function)\n    );\n  });\n\n  it('shows custom fallback when provided', async () => {\n    const CustomAsyncFallback = () => <div>Custom async error</div>;\n    \n    render(\n      <AsyncErrorBoundary fallback={<CustomAsyncFallback />}>\n        <AsyncErrorComponent />\n      </AsyncErrorBoundary>\n    );\n\n    const triggerButton = screen.getByText('Trigger Async Error');\n    \n    act(() => {\n      fireEvent.click(triggerButton);\n    });\n\n    // Wait and check if custom fallback appears (this depends on implementation)\n    // In practice, async errors show as notifications, not full fallbacks\n    expect(screen.getByText('Trigger Async Error')).toBeInTheDocument();\n  });\n});\n\ndescribe('Error Boundary Integration', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  it('nested error boundaries work correctly', async () => {\n    render(\n      <BrowserRouter>\n        <GlobalErrorBoundary>\n          <AsyncErrorBoundary>\n            <RouteErrorBoundary>\n              <ThrowErrorComponent shouldThrow={true} errorMessage=\"Nested error\" />\n            </RouteErrorBoundary>\n          </AsyncErrorBoundary>\n        </GlobalErrorBoundary>\n      </BrowserRouter>\n    );\n\n    // Should be caught by the innermost boundary (RouteErrorBoundary)\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n  });\n\n  it('error boundaries handle different error types appropriately', async () => {\n    const NetworkError = () => {\n      throw new Error('fetch failed - network error');\n    };\n\n    const ChunkError = () => {\n      throw new Error('Loading chunk 123 failed');\n    };\n\n    const { rerender } = render(\n      <GlobalErrorBoundary>\n        <NetworkError />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    rerender(\n      <GlobalErrorBoundary>\n        <ChunkError />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n  });\n\n  it('error recovery works across different boundary types', async () => {\n    let shouldError = true;\n    const RecoverableComponent = () => {\n      if (shouldError) {\n        throw new Error('Recoverable error');\n      }\n      return <div>Recovered successfully</div>;\n    };\n\n    render(\n      <GlobalErrorBoundary>\n        <RecoverableComponent />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    // Simulate successful recovery\n    shouldError = false;\n    const retryButton = screen.getByText('Try Again');\n    \n    act(() => {\n      fireEvent.click(retryButton);\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('Recovered successfully')).toBeInTheDocument();\n    });\n  });\n});\n\ndescribe('Error Boundary Accessibility', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  it('error boundary has proper ARIA attributes', async () => {\n    render(\n      <GlobalErrorBoundary>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      const errorContainer = screen.getByTestId('error-fallback');\n      expect(errorContainer).toBeInTheDocument();\n    });\n  });\n\n  it('focuses on error container when error occurs', async () => {\n    render(\n      <GlobalErrorBoundary>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      const errorContainer = screen.getByTestId('error-fallback');\n      expect(errorContainer).toBeInTheDocument();\n      // Focus management is tested at the component level\n    });\n  });\n\n  it('provides keyboard navigation for recovery actions', async () => {\n    render(\n      <GlobalErrorBoundary>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    const retryButton = screen.getByText('Try Again');\n    const reloadButton = screen.getByText('Reload');\n\n    expect(retryButton).toBeInTheDocument();\n    expect(reloadButton).toBeInTheDocument();\n\n    // Test keyboard interaction\n    retryButton.focus();\n    expect(retryButton).toHaveFocus();\n  });\n});\n\ndescribe('Error Reporting', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  it('shows error report modal when report button is clicked', async () => {\n    render(\n      <GlobalErrorBoundary enableReporting={true}>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    const reportButton = screen.getByText('Report');\n    fireEvent.click(reportButton);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-report-modal')).toBeInTheDocument();\n    });\n  });\n\n  it('submits error report with user description', async () => {\n    const { reportError } = require('../../../utils/errorUtils');\n    \n    render(\n      <GlobalErrorBoundary enableReporting={true}>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    const reportButton = screen.getByText('Report');\n    fireEvent.click(reportButton);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-report-modal')).toBeInTheDocument();\n    });\n\n    const submitButton = screen.getByText('Submit Report');\n    fireEvent.click(submitButton);\n\n    await waitFor(() => {\n      expect(reportError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          userDescription: 'Test description',\n          reproductionSteps: ['Step 1']\n        })\n      );\n    });\n  });\n\n  it('closes modal after successful report submission', async () => {\n    render(\n      <GlobalErrorBoundary enableReporting={true}>\n        <ThrowErrorComponent shouldThrow={true} />\n      </GlobalErrorBoundary>\n    );\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-fallback')).toBeInTheDocument();\n    });\n\n    const reportButton = screen.getByText('Report');\n    fireEvent.click(reportButton);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('error-report-modal')).toBeInTheDocument();\n    });\n\n    const submitButton = screen.getByText('Submit Report');\n    fireEvent.click(submitButton);\n\n    await waitFor(() => {\n      expect(screen.queryByTestId('error-report-modal')).not.toBeInTheDocument();\n    });\n  });\n});