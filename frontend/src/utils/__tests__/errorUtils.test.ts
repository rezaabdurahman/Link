import {\n  generateErrorId,\n  createErrorFingerprint,\n  categorizeError,\n  getErrorSeverity,\n  getRetryConfig,\n  isRecoverable,\n  generateRecoveryStrategies,\n  collectErrorContext,\n  createErrorMetadata,\n  analyzeNetworkError,\n  analyzeChunkLoadingError,\n  shouldReportError\n} from '../errorUtils';\nimport { ErrorType, ErrorSeverity } from '../errorTypes';\nimport { jest } from '@jest/globals';\n\n// Mock Sentry\njest.mock('@sentry/react', () => ({\n  withScope: jest.fn(),\n  captureException: jest.fn(),\n  addBreadcrumb: jest.fn()\n}));\n\ndescribe('errorUtils', () => {\n  describe('generateErrorId', () => {\n    it('generates unique error IDs', () => {\n      const id1 = generateErrorId();\n      const id2 = generateErrorId();\n      \n      expect(id1).toMatch(/^error_\\d+_[a-z0-9]+$/);\n      expect(id2).toMatch(/^error_\\d+_[a-z0-9]+$/);\n      expect(id1).not.toBe(id2);\n    });\n  });\n\n  describe('createErrorFingerprint', () => {\n    it('creates consistent fingerprints for same error', () => {\n      const error1 = new Error('Test error');\n      error1.stack = 'Error: Test error\\n    at test.js:1:1';\n      \n      const error2 = new Error('Test error');\n      error2.stack = 'Error: Test error\\n    at test.js:1:1';\n      \n      const fingerprint1 = createErrorFingerprint(error1);\n      const fingerprint2 = createErrorFingerprint(error2);\n      \n      expect(fingerprint1).toBe(fingerprint2);\n    });\n\n    it('creates different fingerprints for different errors', () => {\n      const error1 = new Error('Test error 1');\n      const error2 = new Error('Test error 2');\n      \n      const fingerprint1 = createErrorFingerprint(error1);\n      const fingerprint2 = createErrorFingerprint(error2);\n      \n      expect(fingerprint1).not.toBe(fingerprint2);\n    });\n\n    it('handles errors without stack traces', () => {\n      const error = new Error('Test error');\n      error.stack = undefined;\n      \n      const fingerprint = createErrorFingerprint(error);\n      \n      expect(fingerprint).toBeTruthy();\n      expect(typeof fingerprint).toBe('string');\n    });\n  });\n\n  describe('categorizeError', () => {\n    it('categorizes chunk loading errors correctly', () => {\n      const error = new Error('Loading chunk 123 failed');\n      expect(categorizeError(error)).toBe(ErrorType.CHUNK_LOADING);\n      \n      const cssError = new Error('Loading CSS chunk failed');\n      expect(categorizeError(cssError)).toBe(ErrorType.CHUNK_LOADING);\n    });\n\n    it('categorizes network errors correctly', () => {\n      const fetchError = new Error('fetch failed');\n      expect(categorizeError(fetchError)).toBe(ErrorType.NETWORK);\n      \n      const networkError = new Error('Network request failed');\n      expect(categorizeError(networkError)).toBe(ErrorType.NETWORK);\n      \n      const corsError = new Error('CORS error occurred');\n      expect(categorizeError(corsError)).toBe(ErrorType.NETWORK);\n    });\n\n    it('categorizes authentication errors correctly', () => {\n      const authError = new Error('Authentication failed');\n      expect(categorizeError(authError)).toBe(ErrorType.AUTHENTICATION);\n      \n      const tokenError = new Error('Token expired');\n      expect(categorizeError(tokenError)).toBe(ErrorType.AUTHENTICATION);\n    });\n\n    it('categorizes permission errors correctly', () => {\n      const permError = new Error('Permission denied');\n      expect(categorizeError(permError)).toBe(ErrorType.PERMISSION);\n      \n      const forbiddenError = new Error('Forbidden access');\n      expect(categorizeError(forbiddenError)).toBe(ErrorType.PERMISSION);\n    });\n\n    it('categorizes validation errors correctly', () => {\n      const validationError = new Error('Validation failed');\n      expect(categorizeError(validationError)).toBe(ErrorType.VALIDATION);\n      \n      const invalidError = new Error('Invalid input provided');\n      expect(categorizeError(invalidError)).toBe(ErrorType.VALIDATION);\n    });\n\n    it('defaults to runtime for generic errors', () => {\n      const genericError = new Error('Something went wrong');\n      expect(categorizeError(genericError)).toBe(ErrorType.RUNTIME);\n      \n      const referenceError = new ReferenceError('undefined variable');\n      expect(categorizeError(referenceError)).toBe(ErrorType.RUNTIME);\n    });\n\n    it('returns unknown for unrecognized error patterns', () => {\n      const strangeError = new Error('');\n      strangeError.name = 'CustomError';\n      expect(categorizeError(strangeError)).toBe(ErrorType.UNKNOWN);\n    });\n  });\n\n  describe('getErrorSeverity', () => {\n    it('assigns critical severity to global errors', () => {\n      const error = new Error('Out of memory');\n      expect(getErrorSeverity(error, ErrorType.GLOBAL)).toBe(ErrorSeverity.CRITICAL);\n    });\n\n    it('assigns high severity to auth and chunk loading errors', () => {\n      const error = new Error('Test error');\n      expect(getErrorSeverity(error, ErrorType.AUTHENTICATION)).toBe(ErrorSeverity.HIGH);\n      expect(getErrorSeverity(error, ErrorType.CHUNK_LOADING)).toBe(ErrorSeverity.HIGH);\n    });\n\n    it('assigns medium severity to network and component errors', () => {\n      const error = new Error('Test error');\n      expect(getErrorSeverity(error, ErrorType.NETWORK)).toBe(ErrorSeverity.MEDIUM);\n      expect(getErrorSeverity(error, ErrorType.COMPONENT)).toBe(ErrorSeverity.MEDIUM);\n    });\n\n    it('assigns low severity as default', () => {\n      const error = new Error('Test error');\n      expect(getErrorSeverity(error, ErrorType.VALIDATION)).toBe(ErrorSeverity.LOW);\n    });\n  });\n\n  describe('getRetryConfig', () => {\n    it('provides correct retry config for network errors', () => {\n      const config = getRetryConfig(ErrorType.NETWORK);\n      expect(config.maxRetries).toBe(3);\n      expect(config.delay).toBe(1000);\n    });\n\n    it('provides correct retry config for chunk loading errors', () => {\n      const config = getRetryConfig(ErrorType.CHUNK_LOADING);\n      expect(config.maxRetries).toBe(2);\n      expect(config.delay).toBe(500);\n    });\n\n    it('provides default retry config for other errors', () => {\n      const config = getRetryConfig(ErrorType.VALIDATION);\n      expect(config.maxRetries).toBe(1);\n      expect(config.delay).toBe(0);\n    });\n  });\n\n  describe('isRecoverable', () => {\n    it('identifies recoverable error types', () => {\n      expect(isRecoverable(ErrorType.NETWORK)).toBe(true);\n      expect(isRecoverable(ErrorType.CHUNK_LOADING)).toBe(true);\n      expect(isRecoverable(ErrorType.COMPONENT)).toBe(true);\n      expect(isRecoverable(ErrorType.ROUTE)).toBe(true);\n      expect(isRecoverable(ErrorType.ASYNC)).toBe(true);\n    });\n\n    it('identifies non-recoverable error types', () => {\n      expect(isRecoverable(ErrorType.PERMISSION)).toBe(false);\n      expect(isRecoverable(ErrorType.AUTHENTICATION)).toBe(false);\n      expect(isRecoverable(ErrorType.VALIDATION)).toBe(false);\n    });\n  });\n\n  describe('generateRecoveryStrategies', () => {\n    it('generates retry strategy for recoverable errors', () => {\n      const metadata = {\n        retryCount: 0,\n        maxRetries: 3,\n        severity: ErrorSeverity.MEDIUM\n      };\n      \n      const strategies = generateRecoveryStrategies(ErrorType.NETWORK, metadata);\n      \n      expect(strategies).toHaveLength(2); // retry + report\n      expect(strategies[0].type).toBe('retry');\n      expect(strategies[0].label).toBe('Try Again');\n    });\n\n    it('generates refresh strategy for chunk loading errors', () => {\n      const metadata = {\n        retryCount: 0,\n        maxRetries: 2,\n        severity: ErrorSeverity.HIGH\n      };\n      \n      const strategies = generateRecoveryStrategies(ErrorType.CHUNK_LOADING, metadata);\n      \n      const refreshStrategy = strategies.find(s => s.type === 'refresh');\n      expect(refreshStrategy).toBeDefined();\n      expect(refreshStrategy!.label).toBe('Refresh Page');\n    });\n\n    it('generates navigation strategies for route errors', () => {\n      const metadata = {\n        retryCount: 0,\n        maxRetries: 2,\n        severity: ErrorSeverity.MEDIUM\n      };\n      \n      const mockNavigate = jest.fn();\n      const context = { navigate: mockNavigate };\n      \n      const strategies = generateRecoveryStrategies(ErrorType.ROUTE, metadata, context);\n      \n      const homeStrategy = strategies.find(s => s.label === 'Go Home');\n      const backStrategy = strategies.find(s => s.label === 'Go Back');\n      \n      expect(homeStrategy).toBeDefined();\n      expect(backStrategy).toBeDefined();\n    });\n\n    it('excludes retry strategy when max retries exceeded', () => {\n      const metadata = {\n        retryCount: 3,\n        maxRetries: 3,\n        severity: ErrorSeverity.MEDIUM\n      };\n      \n      const strategies = generateRecoveryStrategies(ErrorType.NETWORK, metadata);\n      \n      const retryStrategy = strategies.find(s => s.type === 'retry');\n      expect(retryStrategy).toBeUndefined();\n    });\n\n    it('includes report strategy for non-low severity errors', () => {\n      const metadata = {\n        retryCount: 0,\n        maxRetries: 3,\n        severity: ErrorSeverity.HIGH\n      };\n      \n      const strategies = generateRecoveryStrategies(ErrorType.NETWORK, metadata);\n      \n      const reportStrategy = strategies.find(s => s.type === 'report');\n      expect(reportStrategy).toBeDefined();\n      expect(reportStrategy!.label).toBe('Report Issue');\n    });\n  });\n\n  describe('collectErrorContext', () => {\n    beforeEach(() => {\n      // Mock window properties\n      Object.defineProperty(window, 'innerWidth', { value: 1024, writable: true });\n      Object.defineProperty(window, 'innerHeight', { value: 768, writable: true });\n      Object.defineProperty(window, 'location', {\n        value: { pathname: '/test' },\n        writable: true\n      });\n      Object.defineProperty(navigator, 'userAgent', {\n        value: 'Mozilla/5.0 (Test Browser)',\n        writable: true\n      });\n    });\n\n    it('collects basic error context', async () => {\n      const context = await collectErrorContext();\n      \n      expect(context.userAgent).toBe('Mozilla/5.0 (Test Browser)');\n      expect(context.viewport.width).toBe(1024);\n      expect(context.viewport.height).toBe(768);\n      expect(context.route).toBe('/test');\n    });\n\n    it('includes connection info when available', async () => {\n      // Mock navigator.connection\n      Object.defineProperty(navigator, 'connection', {\n        value: {\n          effectiveType: '4g',\n          downlink: 10,\n          rtt: 100\n        },\n        writable: true\n      });\n      \n      const context = await collectErrorContext();\n      \n      expect(context.connection).toEqual({\n        type: '4g',\n        downlink: 10,\n        rtt: 100\n      });\n    });\n\n    it('includes performance info when available', async () => {\n      // Mock performance\n      Object.defineProperty(window, 'performance', {\n        value: {\n          memory: { usedJSHeapSize: 1000000 },\n          timing: { navigationStart: Date.now() }\n        },\n        writable: true\n      });\n      \n      const context = await collectErrorContext();\n      \n      expect(context.performance).toBeDefined();\n      expect(context.performance!.memory).toEqual({ usedJSHeapSize: 1000000 });\n    });\n  });\n\n  describe('createErrorMetadata', () => {\n    it('creates comprehensive error metadata', async () => {\n      const error = new Error('Test error');\n      const errorInfo = {\n        componentStack: 'Component stack trace'\n      } as any;\n      \n      const metadata = await createErrorMetadata(error, errorInfo, {\n        level: 'test',\n        userId: 'user123'\n      });\n      \n      expect(metadata.id).toMatch(/^error_\\d+_[a-z0-9]+$/);\n      expect(metadata.type).toBe(ErrorType.RUNTIME);\n      expect(metadata.severity).toBe(ErrorSeverity.LOW);\n      expect(metadata.timestamp).toBeGreaterThan(0);\n      expect(metadata.userId).toBe('user123');\n      expect(metadata.stackTrace).toBe(error.stack);\n      expect(metadata.componentStack).toBe('Component stack trace');\n    });\n\n    it('handles missing errorInfo', async () => {\n      const error = new Error('Test error');\n      \n      const metadata = await createErrorMetadata(error);\n      \n      expect(metadata.componentStack).toBeUndefined();\n      expect(metadata.id).toBeTruthy();\n    });\n\n    it('includes build version from environment', async () => {\n      // Mock environment variable\n      const originalEnv = import.meta.env;\n      (import.meta as any).env = { ...originalEnv, VITE_APP_VERSION: '1.0.0' };\n      \n      const error = new Error('Test error');\n      const metadata = await createErrorMetadata(error);\n      \n      expect(metadata.buildVersion).toBe('1.0.0');\n      \n      // Restore original env\n      (import.meta as any).env = originalEnv;\n    });\n  });\n\n  describe('analyzeNetworkError', () => {\n    it('detects fetch errors', () => {\n      const error = new Error('fetch failed');\n      const analysis = analyzeNetworkError(error);\n      \n      expect(analysis).not.toBeNull();\n      expect(analysis!.url).toBeTruthy();\n      expect(analysis!.offline).toBe(false); // Default navigator.onLine is true\n    });\n\n    it('detects timeout errors', () => {\n      const error = new Error('Request timeout occurred');\n      const analysis = analyzeNetworkError(error);\n      \n      expect(analysis).not.toBeNull();\n      expect(analysis!.timeout).toBe(true);\n    });\n\n    it('detects CORS errors', () => {\n      const error = new Error('CORS policy violation');\n      const analysis = analyzeNetworkError(error);\n      \n      expect(analysis).not.toBeNull();\n      expect(analysis!.cors).toBe(true);\n    });\n\n    it('returns null for non-network errors', () => {\n      const error = new Error('Generic error');\n      const analysis = analyzeNetworkError(error);\n      \n      expect(analysis).toBeNull();\n    });\n  });\n\n  describe('analyzeChunkLoadingError', () => {\n    it('detects chunk loading errors', () => {\n      const error = new Error('Loading chunk 123 failed');\n      const analysis = analyzeChunkLoadingError(error);\n      \n      expect(analysis).not.toBeNull();\n      expect(analysis!.chunkName).toBe('123');\n      expect(analysis!.networkStatus).toBe('online');\n    });\n\n    it('handles offline scenarios', () => {\n      // Mock navigator.onLine\n      Object.defineProperty(navigator, 'onLine', { value: false, writable: true });\n      \n      const error = new Error('chunk loading failed');\n      const analysis = analyzeChunkLoadingError(error);\n      \n      expect(analysis).not.toBeNull();\n      expect(analysis!.networkStatus).toBe('offline');\n    });\n\n    it('returns null for non-chunk errors', () => {\n      const error = new Error('Generic error');\n      const analysis = analyzeChunkLoadingError(error);\n      \n      expect(analysis).toBeNull();\n    });\n  });\n\n  describe('shouldReportError', () => {\n    beforeEach(() => {\n      // Clear the error report cache between tests\n      const cache = (shouldReportError as any).__cache;\n      if (cache) {\n        cache.clear();\n      }\n    });\n\n    it('allows reporting new error fingerprints', () => {\n      const fingerprint = 'test-fingerprint-1';\n      \n      expect(shouldReportError(fingerprint)).toBe(true);\n    });\n\n    it('prevents spam reporting of same fingerprint', () => {\n      const fingerprint = 'test-fingerprint-2';\n      \n      expect(shouldReportError(fingerprint)).toBe(true);\n      expect(shouldReportError(fingerprint)).toBe(false);\n    });\n\n    it('allows reporting again after debounce period', (done) => {\n      const fingerprint = 'test-fingerprint-3';\n      \n      expect(shouldReportError(fingerprint)).toBe(true);\n      expect(shouldReportError(fingerprint)).toBe(false);\n      \n      // Wait for debounce period (this would be much longer in real implementation)\n      setTimeout(() => {\n        expect(shouldReportError(fingerprint)).toBe(true);\n        done();\n      }, 10); // Using short timeout for tests\n    });\n  });\n});