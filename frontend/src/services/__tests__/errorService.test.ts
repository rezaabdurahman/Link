import { jest } from '@jest/globals';\nimport { ErrorService } from '../errorService';\nimport { ErrorType, ErrorSeverity, ErrorBoundaryConfig } from '../../utils/errorTypes';\n\n// Mock dependencies\njest.mock('../../utils/errorUtils', () => ({\n  createErrorMetadata: jest.fn().mockResolvedValue({\n    id: 'test-error-id',\n    type: 'runtime',\n    severity: 'medium',\n    timestamp: Date.now(),\n    userAgent: 'test-agent',\n    url: 'http://localhost',\n    fingerprint: 'test-fingerprint',\n    context: {},\n    stackTrace: 'Error stack trace',\n    retryCount: 0,\n    maxRetries: 3,\n    isRecoverable: true,\n    recoveryStrategies: [],\n    tags: { errorType: 'runtime', severity: 'medium' }\n  }),\n  generateRecoveryStrategies: jest.fn().mockReturnValue([\n    {\n      type: 'retry',\n      label: 'Try Again',\n      description: 'Retry the operation',\n      action: jest.fn(),\n      priority: 1\n    }\n  ]),\n  reportError: jest.fn().mockResolvedValue(undefined),\n  shouldReportError: jest.fn().mockReturnValue(true),\n  trackErrorRecovery: jest.fn(),\n  analyzeNetworkError: jest.fn().mockReturnValue(null),\n  analyzeChunkLoadingError: jest.fn().mockReturnValue(null),\n  collectErrorContext: jest.fn().mockResolvedValue({\n    userAgent: 'test-agent',\n    viewport: { width: 1024, height: 768 },\n    route: '/test'\n  })\n}));\n\njest.mock('@sentry/react', () => ({\n  withScope: jest.fn(),\n  captureException: jest.fn(),\n  addBreadcrumb: jest.fn(),\n  captureMessage: jest.fn()\n}));\n\ndescribe('ErrorService', () => {\n  let errorService: ErrorService;\n  let mockAnalytics: any;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    \n    mockAnalytics = {\n      track: jest.fn(),\n      identify: jest.fn(),\n      increment: jest.fn(),\n      timing: jest.fn()\n    };\n\n    errorService = new (ErrorService as any)({\n      level: 'test',\n      maxRetries: 3,\n      retryDelay: 1000,\n      enableReporting: true,\n      enableAnalytics: true\n    });\n\n    errorService.setAnalytics(mockAnalytics);\n  });\n\n  describe('constructor', () => {\n    it('initializes with default configuration', () => {\n      const service = new (ErrorService as any)();\n      expect(service).toBeDefined();\n    });\n\n    it('initializes with custom configuration', () => {\n      const config: Partial<ErrorBoundaryConfig> = {\n        level: 'custom',\n        maxRetries: 5,\n        enableReporting: false\n      };\n\n      const service = new (ErrorService as any)(config);\n      expect(service).toBeDefined();\n    });\n  });\n\n  describe('handleError', () => {\n    it('handles error and returns metadata', async () => {\n      const error = new Error('Test error');\n      const errorInfo = { componentStack: 'Component stack' } as any;\n\n      const result = await errorService.handleError(error, errorInfo);\n\n      expect(result).toBeDefined();\n      expect(result.id).toBe('test-error-id');\n      expect(result.type).toBe('runtime');\n    });\n\n    it('ignores errors that match ignored patterns', async () => {\n      const service = new (ErrorService as any)({\n        ignoredErrors: [/Test ignored error/]\n      });\n\n      const error = new Error('Test ignored error');\n      \n      await expect(service.handleError(error)).rejects.toThrow('Error ignored by configuration');\n    });\n\n    it('reports error when reporting is enabled', async () => {\n      const { reportError } = require('../../utils/errorUtils');\n      \n      const error = new Error('Test error');\n      await errorService.handleError(error);\n\n      expect(reportError).toHaveBeenCalled();\n    });\n\n    it('tracks analytics when analytics is enabled', async () => {\n      const error = new Error('Test error');\n      await errorService.handleError(error);\n\n      expect(mockAnalytics.track).toHaveBeenCalledWith(\n        'error_occurred',\n        expect.objectContaining({\n          errorId: 'test-error-id',\n          errorType: 'runtime',\n          severity: 'medium'\n        })\n      );\n    });\n\n    it('adds error to history', async () => {\n      const error = new Error('Test error');\n      await errorService.handleError(error);\n\n      const stats = errorService.getErrorStats();\n      expect(stats.totalErrors).toBe(1);\n    });\n  });\n\n  describe('executeRecovery', () => {\n    it('executes recovery strategy successfully', async () => {\n      const mockAction = jest.fn().mockResolvedValue(undefined);\n      const strategy = {\n        type: 'retry' as const,\n        label: 'Try Again',\n        description: 'Retry the operation',\n        action: mockAction,\n        priority: 1\n      };\n\n      const metadata = {\n        fingerprint: 'test-fingerprint',\n        id: 'test-error-id'\n      } as any;\n\n      const result = await errorService.executeRecovery(metadata, strategy);\n\n      expect(result).toBe(true);\n      expect(mockAction).toHaveBeenCalled();\n      expect(mockAnalytics.track).toHaveBeenCalledWith(\n        'recovery_attempted',\n        expect.any(Object)\n      );\n    });\n\n    it('handles recovery strategy failure', async () => {\n      const mockAction = jest.fn().mockRejectedValue(new Error('Recovery failed'));\n      const strategy = {\n        type: 'retry' as const,\n        label: 'Try Again',\n        description: 'Retry the operation',\n        action: mockAction,\n        priority: 1\n      };\n\n      const metadata = {\n        fingerprint: 'test-fingerprint',\n        id: 'test-error-id'\n      } as any;\n\n      const result = await errorService.executeRecovery(metadata, strategy);\n\n      expect(result).toBe(false);\n      expect(mockAnalytics.track).toHaveBeenCalledWith(\n        'recovery_failed',\n        expect.objectContaining({\n          errorId: 'test-error-id',\n          strategyType: 'retry'\n        })\n      );\n    });\n\n    it('prevents infinite recovery loops', async () => {\n      const strategy = {\n        type: 'retry' as const,\n        label: 'Try Again',\n        description: 'Retry the operation',\n        action: jest.fn(),\n        priority: 1\n      };\n\n      const metadata = {\n        fingerprint: 'test-fingerprint',\n        id: 'test-error-id'\n      } as any;\n\n      // Execute recovery 3 times\n      await errorService.executeRecovery(metadata, strategy);\n      await errorService.executeRecovery(metadata, strategy);\n      await errorService.executeRecovery(metadata, strategy);\n      \n      // Fourth attempt should be blocked\n      const result = await errorService.executeRecovery(metadata, strategy);\n      expect(result).toBe(false);\n    });\n  });\n\n  describe('error pattern analysis', () => {\n    it('detects error storms', async () => {\n      const error = new Error('Repeated error');\n      \n      // Simulate multiple errors with same fingerprint\n      for (let i = 0; i < 6; i++) {\n        await errorService.handleError(error);\n      }\n\n      // Should have tracked error storm\n      expect(mockAnalytics.track).toHaveBeenCalledWith(\n        'error_storm_detected',\n        expect.objectContaining({\n          fingerprint: 'test-fingerprint'\n        })\n      );\n    });\n\n    it('tracks error frequency patterns', async () => {\n      const error1 = new Error('Error 1');\n      const error2 = new Error('Error 2');\n      \n      await errorService.handleError(error1);\n      await errorService.handleError(error2);\n\n      const stats = errorService.getErrorStats();\n      expect(stats.totalErrors).toBe(2);\n    });\n  });\n\n  describe('getErrorStats', () => {\n    it('returns comprehensive error statistics', async () => {\n      const error1 = new Error('Network error');\n      const error2 = new Error('Component error');\n      \n      await errorService.handleError(error1);\n      await errorService.handleError(error2);\n\n      const stats = errorService.getErrorStats();\n      \n      expect(stats.totalErrors).toBe(2);\n      expect(stats.byType.runtime).toBe(2);\n      expect(stats.bySeverity.medium).toBe(2);\n      expect(stats.recentPatterns).toHaveLength(2);\n    });\n\n    it('sorts patterns by recent activity', async () => {\n      const error1 = new Error('First error');\n      await errorService.handleError(error1);\n      \n      // Wait a bit\n      await new Promise(resolve => setTimeout(resolve, 10));\n      \n      const error2 = new Error('Second error');\n      await errorService.handleError(error2);\n\n      const stats = errorService.getErrorStats();\n      \n      expect(stats.recentPatterns[0].lastSeen).toBeGreaterThan(\n        stats.recentPatterns[1].lastSeen\n      );\n    });\n  });\n\n  describe('cleanup', () => {\n    it('cleans up old error history', async () => {\n      const error = new Error('Old error');\n      await errorService.handleError(error);\n\n      // Clean up with very short max age\n      errorService.cleanupHistory(1); // 1 millisecond\n      \n      await new Promise(resolve => setTimeout(resolve, 10));\n      \n      const stats = errorService.getErrorStats();\n      expect(stats.totalErrors).toBe(0);\n    });\n\n    it('preserves recent errors during cleanup', async () => {\n      const error = new Error('Recent error');\n      await errorService.handleError(error);\n\n      // Clean up with long max age\n      errorService.cleanupHistory(60000); // 1 minute\n      \n      const stats = errorService.getErrorStats();\n      expect(stats.totalErrors).toBe(1);\n    });\n  });\n\n  describe('analytics integration', () => {\n    it('tracks error metrics correctly', async () => {\n      const error = new Error('Analytics test error');\n      await errorService.handleError(error);\n\n      expect(mockAnalytics.increment).toHaveBeenCalledWith('errors.total');\n      expect(mockAnalytics.increment).toHaveBeenCalledWith('errors.by_type.runtime');\n      expect(mockAnalytics.increment).toHaveBeenCalledWith('errors.by_severity.medium');\n    });\n\n    it('tracks recovery attempts', async () => {\n      const strategy = {\n        type: 'retry' as const,\n        label: 'Try Again',\n        description: 'Retry the operation',\n        action: jest.fn().mockResolvedValue(undefined),\n        priority: 1\n      };\n\n      const metadata = {\n        fingerprint: 'test-fingerprint',\n        id: 'test-error-id',\n        type: 'runtime',\n        retryCount: 0\n      } as any;\n\n      await errorService.executeRecovery(metadata, strategy);\n\n      expect(mockAnalytics.track).toHaveBeenCalledWith(\n        'recovery_attempted',\n        expect.objectContaining({\n          errorId: 'test-error-id',\n          strategyType: 'retry'\n        })\n      );\n    });\n  });\n\n  describe('special error analysis', () => {\n    beforeEach(() => {\n      const { analyzeNetworkError, analyzeChunkLoadingError } = require('../../utils/errorUtils');\n      \n      analyzeNetworkError.mockReturnValue({\n        url: 'http://test.com',\n        offline: false,\n        timeout: false\n      });\n      \n      analyzeChunkLoadingError.mockReturnValue({\n        chunkName: '123',\n        networkStatus: 'online',\n        publicPath: '/'\n      });\n    });\n\n    it('analyzes network errors and adds context', async () => {\n      const networkError = new Error('fetch failed');\n      const metadata = await errorService.handleError(networkError);\n\n      expect(metadata.context.networkDetails).toBeDefined();\n    });\n\n    it('analyzes chunk loading errors and adds recovery strategies', async () => {\n      const { analyzeChunkLoadingError } = require('../../utils/errorUtils');\n      \n      analyzeChunkLoadingError.mockReturnValue({\n        chunkName: '123',\n        networkStatus: 'offline',\n        publicPath: '/'\n      });\n\n      const chunkError = new Error('Loading chunk 123 failed');\n      const metadata = await errorService.handleError(chunkError);\n\n      expect(metadata.context.chunkDetails).toBeDefined();\n      expect(metadata.severity).toBe('high'); // Should be upgraded for offline scenarios\n    });\n\n    it('detects memory pressure and adds recovery strategies', async () => {\n      // Mock performance.memory\n      const mockMemory = {\n        usedJSHeapSize: 95000000,\n        jsHeapSizeLimit: 100000000\n      };\n      \n      Object.defineProperty(performance, 'memory', {\n        value: mockMemory,\n        configurable: true\n      });\n\n      const error = new Error('Memory pressure test');\n      const metadata = await errorService.handleError(error);\n\n      expect(metadata.context.memoryPressure).toBeDefined();\n      expect(metadata.context.memoryPressure.pressure).toBeCloseTo(0.95);\n    });\n  });\n\n  describe('error configuration', () => {\n    it('respects ignored error patterns', async () => {\n      const service = new (ErrorService as any)({\n        ignoredErrors: [\n          'ResizeObserver loop limit exceeded',\n          /extension/i,\n          /^Script error\\.$/\n        ]\n      });\n\n      const ignoredError1 = new Error('ResizeObserver loop limit exceeded');\n      const ignoredError2 = new Error('Chrome extension error');\n      const ignoredError3 = new Error('Script error.');\n      const validError = new Error('Valid error');\n\n      await expect(service.handleError(ignoredError1)).rejects.toThrow();\n      await expect(service.handleError(ignoredError2)).rejects.toThrow();\n      await expect(service.handleError(ignoredError3)).rejects.toThrow();\n      \n      const result = await service.handleError(validError);\n      expect(result).toBeDefined();\n    });\n\n    it('allows custom recovery strategies', async () => {\n      const customStrategy = {\n        type: 'custom' as const,\n        label: 'Custom Recovery',\n        description: 'Custom recovery action',\n        action: jest.fn(),\n        priority: 0\n      };\n\n      const service = new (ErrorService as any)({\n        customRecoveryStrategies: [customStrategy]\n      });\n\n      const error = new Error('Test error');\n      const metadata = await service.handleError(error);\n\n      expect(metadata.recoveryStrategies).toContainEqual(customStrategy);\n    });\n  });\n});