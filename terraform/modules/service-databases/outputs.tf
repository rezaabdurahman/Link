# Outputs for Service Databases Terraform Module

# Service database information
output "service_databases" {
  description = "Map of service names to their database configurations"
  value = {
    for service_key, service_config in local.services : service_key => {
      database_name = postgresql_database.service_databases[service_key].name
      username      = postgresql_role.service_users[service_key].name
      description   = service_config.description
    }
  }
}

# Service connection strings (without passwords for security)
output "service_connection_info" {
  description = "Connection information for each service (passwords excluded)"
  value = {
    for service_key, service_config in local.services : service_key => {
      database_name = postgresql_database.service_databases[service_key].name
      username      = postgresql_role.service_users[service_key].name
      port          = 5432
      ssl_mode      = var.enable_ssl ? "require" : "disable"
    }
  }
}

# Service passwords (marked as sensitive)
output "service_passwords" {
  description = "Generated passwords for each service database user"
  value = {
    for service_key in keys(local.services) : service_key => random_password.service_passwords[service_key].result
  }
  sensitive = true
}

# Kubernetes secret data for each service
output "kubernetes_secrets" {
  description = "Kubernetes secret data for each service"
  value = {
    for service_key, service_config in local.services : service_key => {
      name = "${service_key}-db-credentials"
      data = {
        DB_HOST     = var.environment == "production" ? "postgres.default.svc.cluster.local" : "postgres"
        DB_PORT     = "5432"
        DB_NAME     = postgresql_database.service_databases[service_key].name
        DB_USER     = postgresql_role.service_users[service_key].name
        DB_PASSWORD = random_password.service_passwords[service_key].result
        DB_SSLMODE  = var.enable_ssl ? "require" : "disable"
        # Connection pool settings for multi-instance deployment
        DB_MAX_OPEN_CONNS    = tostring(local.connection_pool_settings.max_open_connections)
        DB_MAX_IDLE_CONNS    = tostring(local.connection_pool_settings.max_idle_connections)
        DB_CONN_MAX_LIFETIME = local.connection_pool_settings.connection_max_lifetime
      }
    }
  }
  sensitive = true
}

# Environment files content for local development
output "env_files" {
  description = "Environment file contents for each service"
  value = {
    for service_key, service_config in local.services : service_key => {
      filename = ".env.${service_key}"
      content = join("\n", [
        "# Database configuration for ${service_key} service",
        "# Generated by Terraform service-databases module",
        "",
        "DB_HOST=${var.environment == "production" ? "postgres.default.svc.cluster.local" : "postgres"}",
        "DB_PORT=5432",
        "DB_NAME=${postgresql_database.service_databases[service_key].name}",
        "DB_USER=${postgresql_role.service_users[service_key].name}",
        "DB_PASSWORD=${random_password.service_passwords[service_key].result}",
        "DB_SSLMODE=${var.enable_ssl ? "require" : "disable"}",
        "",
        "# Connection pool settings for multi-instance deployment",
        "DB_MAX_OPEN_CONNS=${local.connection_pool_settings.max_open_connections}",
        "DB_MAX_IDLE_CONNS=${local.connection_pool_settings.max_idle_connections}",
        "DB_CONN_MAX_LIFETIME=${local.connection_pool_settings.connection_max_lifetime}",
        ""
      ])
    }
  }
  sensitive = true
}

# Docker Compose environment configuration
output "docker_compose_env" {
  description = "Docker Compose environment configuration for each service"
  value = {
    for service_key, service_config in local.services : service_key => {
      DB_HOST     = "postgres"
      DB_PORT     = 5432
      DB_NAME     = postgresql_database.service_databases[service_key].name
      DB_USER     = postgresql_role.service_users[service_key].name
      DB_PASSWORD = random_password.service_passwords[service_key].result
      DB_SSLMODE  = var.enable_ssl ? "require" : "disable"
    }
  }
  sensitive = true
}

# Monitoring user information (if created)
output "monitoring_user" {
  description = "Monitoring user information for database observability"
  value = var.create_monitoring_user ? {
    username  = postgresql_role.monitoring_user[0].name
    password  = random_password.monitoring_password[0].result
    databases = [for db in postgresql_database.service_databases : db.name]
  } : null
  sensitive = true
}

# Connection pool settings
output "connection_pool_settings" {
  description = "Recommended connection pool settings for multi-instance deployment"
  value       = local.connection_pool_settings
}

# Expected connection usage summary
output "connection_usage_summary" {
  description = "Expected database connection usage with multi-instance deployment"
  value = {
    before_isolation            = "500+ connections with shared database"
    after_isolation             = "~90 connections (10 per service Ã— ~9 instances)"
    max_connections_per_service = local.connection_pool_settings.max_open_connections
    total_services              = length(local.services)
    estimated_instances = {
      "api-gateway"   = 3
      "user-svc"      = 2
      "chat-svc"      = 2
      "ai-svc"        = 1
      "search-svc"    = 1
      "discovery-svc" = 1
    }
  }
}

# Backup configuration recommendations
output "backup_recommendations" {
  description = "Backup configuration recommendations for service databases"
  value = {
    databases_to_backup = [for db in postgresql_database.service_databases : db.name]
    retention_days      = var.backup_retention_days
    backup_schedule     = "0 2 * * *" # Daily at 2 AM
    backup_strategy     = "Individual database backups + cluster-wide backup"
    restore_testing     = "Monthly restore tests recommended"
  }
}
